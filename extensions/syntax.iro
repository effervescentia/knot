#################################################################
## Iro
################################################################
##
## * Press Ctrl + '+'/'-' To Zoom in
## * Press Ctrl + S to save and recalculate...
## * Documents are saved to web storage.
## * Only one save slot supported.
## * Matches cannot span lines.
## * Unicode chars must be defined in \u0000 to \uffff format.
## * All matches must be contained by a single group ( ... )
## * Look behinds not permitted, (?<= or (?<!
## * Look forwards are permitted (?= or (?!
## * Constants are defined as __my_const = (......)
## * The \= format allows unescaped regular expressions
## * Constants referenced by match \= $${__my_const}
## * Constants can reference other constants
## * You are free to delete all the default scopes.
## * Twitter : ainslec , Web: http://eeyo.io/iro
##
################################################################

name                   = knot
file_extensions []     = kn;

################################################################
## Constants
################################################################

__IMPORT          \= \bimport\b
__FROM            \= \bfrom\b
__AS              \= \bas\b
__MAIN            \= \bmain\b
__KEYWORDS        \= ($${__IMPORT}|$${__FROM}|$${__AS}|$${__MAIN})

__CONST           \= \bconst\b
__LET             \= \blet\b
__STORAGE         \= ($${__CONST}|$${__LET})
__TYPE            \= \btype\b
__TYPE_STORAGE    \= ($${__TYPE})

__TRUE            \= \btrue\b
__FALSE           \= \bfalse\b
__NIL             \= \bnil\b

__IDENTIFIER      \= \b[_a-zA-Z]\w+\b
__JSX_TAG         \= \b_?[a-z]\w*\b
__JSX_COMPONENT   \= \b_?[A-Z]\w*\b

__FLOAT           \= ((?:-\d+\.\d+)|(?:\d+\.\d+))
__INTEGER         \= ((?:-\d+)|(?:\d+))

__BOOL_TYPE       \= \bbool\b
__NIL_TYPE        \= \bnil\b
__STRING_TYPE     \= \bstring\b
__INT_TYPE        \= \bint\b
__FLOAT_TYPE      \= \bfloat\b
__ELEMENT_TYPE    \= \belement\b
__PRIMITIVE_TYPE  \= ($${__BOOL_TYPE}|$${__NIL_TYPE}|$${__INT_TYPE}|$${__FLOAT_TYPE}|$${__STRING_TYPE}|$${__ELEMENT_TYPE})

__LOGIC           \= (\|\||&&|!)
__ARITHMETIC      \= ([+\-*/^])
__RELATIONAL      \= (<=|>=|<|>)
__EQUALITY        \= (==|!=)
__ASSIGN          \= (=)

__PUNCTUATION     \= (</|/>|[:])

################################################################
## Styles
################################################################

styles [] {

// keywords

.keyword : style {
   color          = pink
   ace_scope      = keyword.control
   textmate_scope = keyword.control
}

.main_keyword : style {
   color          = pink
   ace_scope      = keyword.control.main
   textmate_scope = keyword.control.main
}

.import_keyword : style {
   color          = pink
   ace_scope      = keyword.control.import
   textmate_scope = keyword.control.import
}

.from_keyword : style {
   color          = pink
   ace_scope      = keyword.control.from
   textmate_scope = keyword.control.from
}

.as_keyword : style {
   color          = pink
   ace_scope      = keyword.control.as
   textmate_scope = keyword.control.as
}

// storage

.storage : style {
   color          = red
   ace_scope      = storage.type
   textmate_scope = storage.type
}

.type_storage : style {
   color          = red
   ace_scope      = storage.type.type
   textmate_scope = storage.type.type
}

// primitive

.integer : style {
   color          = purple
   ace_scope      = constant.numeric.integer
   textmate_scope = constant.numeric.integer
}

.float : style {
   color          = purple
   ace_scope      = constant.numeric.decimal
   textmate_scope = constant.numeric.decimal
}

.nil : style {
   color          = purple
   ace_scope      = constant.language.boolean.nil
   textmate_scope = constant.language.boolean.nil
}

.boolean_true : style {
   color          = purple
   ace_scope      = constant.language.boolean.true
   textmate_scope = constant.language.boolean.true
}

.boolean_false : style {
   color          = purple
   ace_scope      = constant.language.boolean.false
   textmate_scope = constant.language.boolean.false
}

// string

.string_start_punctuation : style {
   color          = yellow
   ace_scope      = punctuation.definition.string.begin
   textmate_scope = punctuation.definition.string.begin
}

.string_end_punctuation : style {
   color          = yellow
   ace_scope      = punctuation.definition.string.end
   textmate_scope = punctuation.definition.string.end
}

.text : style {
   color          = gold
   ace_scope      = string.quoted.double
   textmate_scope = string.quoted.double
}

// identifier

.identifier : style {
   color          = green
   ace_scope      = variable
   textmate_scope = variable
}

.constant_name : style {
   color          = orange
   ace_scope      = variable.other.constant
   textmate_scope = variable.other.constant
}

.variable_name : style {
   color          = orange
   ace_scope      = variable.other
   textmate_scope = variable.other
}

// jsx

.jsx_tag : style {
   color          = light_green
   ace_scope      = entity.name.tag
   textmate_scope = entity.name.tag
}

.jsx_component : style {
   color          = cyan
   ace_scope      = support.class.view
   textmate_scope = support.class.view
}

.jsx_property : style {
   color          = light_blue
   ace_scope      = entity.other.attribute-name
   textmate_scope = entity.other.attribute-name
}

.jsx_text : style {
   color          = gold
   ace_scope      = string.unquoted
   textmate_scope = string.unquoted
}

.tag_begin_punctuation : style {
   color          = grey
   ace_scope      = punctuation.definition.tag.begin
   textmate_scope = punctuation.definition.tag.begin
}

.tag_end_punctuation : style {
   color          = grey
   ace_scope      = punctuation.definition.tag.end
   textmate_scope = punctuation.definition.tag.end
}

// type definition

.type_alias : style {
   color          = cyan
   ace_scope      = entity.name.type.alias
   textmate_scope = entity.name.type.alias
}

.primitive_type : style {
   color          = cyan
   ace_scope      = support.type.primitive
   textmate_scope = support.type.primitive
}

.type_parameter_begin : style {
   color          = white
   ace_scope      = punctuation.definition.typeparameters.begin
   textmate_scope = punctuation.definition.typeparameters.begin
}

.type_parameter_end : style {
   color          = white
   ace_scope      = punctuation.definition.typeparameters.end
   textmate_scope = punctuation.definition.typeparameters.end
}

.typedef_punctuation : style {
   color          = white
   ace_scope      = keyword.operator.type.annotation
   textmate_scope = keyword.operator.type.annotation
}

// operator

.equality_operator : style {
   color          = red
   ace_scope      = keyword.operator.equality
   textmate_scope = keyword.operator.equality
}

.logical_operator : style {
   color          = red
   ace_scope      = keyword.operator.logical
   textmate_scope = keyword.operator.logical
}

.arithmetic_operator : style {
   color          = red
   ace_scope      = keyword.operator.arithmetic
   textmate_scope = keyword.operator.arithmetic
}

.relational_operator : style {
   color          = red
   ace_scope      = keyword.operator.relational
   textmate_scope = keyword.operator.relational
}

.assignment_operator : style {
   color          = red
   ace_scope      = keyword.operator.assignment
   textmate_scope = keyword.operator.assignment
}

// punctuation

.punctuation : style {
   color          = white
   ace_scope      = punctuation
   textmate_scope = punctuation
}

.terminal_punctuation : style {
   color          = white
   ace_scope      = punctuation.terminal.statement
   textmate_scope = punctuation.terminal.statement
}

.separator_punctuation : style {
   color          = white
   ace_scope      = punctuation.separator.comma
   textmate_scope = punctuation.separator.comma
}

.parenthese_punctuation : style {
   color          = white
   ace_scope      = meta.brace.round
   textmate_scope = meta.brace.round
}

.block_punctuation : style {
   color          = white
   ace_scope      = punctuation.definition.block
   textmate_scope = punctuation.definition.block
}

// misc

.whitespace : style ;

}

#################################################
## Parse contexts
#################################################

contexts [] {

##############################################
## Main Context - Entry point context
##############################################

main : context {

   : include "keyword";
   : include "declaration";
   : include "storage";
   : include "type_definition";
   : include "parameterized_type";
   : include "jsx";
   : include "block_closure";
   : include "primitive";
   : include "group_closure";
   : include "operator";
   : include "punctuation";
   : include "identifier";
   : include "whitespace";
}

#################################################
## End of Contexts
#################################################

###########################################
## Keyword Context
###########################################

keyword : context {

   : pattern {
      regex       \= (\s*)($${__MAIN})(\s*)
      styles []   = .whitespace, .main_keyword, .whitespace;
   }

   : pattern {
      regex       \= (\s*)($${__IMPORT})(\s*)
      styles []   = .whitespace, .import_keyword, .whitespace;
   }

   : pattern {
      regex       \= (\s*)($${__FROM})(\s*)
      styles []   = .whitespace, .from_keyword, .whitespace;
   }

   : pattern {
      regex       \= (\s*)($${__AS})(\s*)
      styles []   = .whitespace, .as_keyword, .whitespace;
   }

   : pattern {
      regex       \= $${__KEYWORDS}
      styles []   = .keyword;
   }

}

###########################################
## Declaration Context
###########################################

declaration : context {

   : pattern {
      regex       \= ($${__CONST})(\s+)($${__IDENTIFIER})(\s*)$${__ASSIGN}(\s*)
      styles []   = .storage, .whitespace, .constant_name, .whitespace, .assignment_operator, .whitespace;
   }

   : pattern {
      regex       \= ($${__LET})(\s+)($${__IDENTIFIER})(\s*)$${__ASSIGN}(\s*)
      styles []   = .storage, .whitespace, .variable_name, .whitespace, .assignment_operator, .whitespace;
   }

   : pattern {
      regex       \= ($${__CONST})(\s+)($${__IDENTIFIER})
      styles []   = .storage, .whitespace, .constant_name;
   }

   : pattern {
      regex       \= ($${__LET})(\s+)($${__IDENTIFIER})
      styles []   = .storage, .whitespace, .variable_name;
   }

}

###########################################
## Storage Context
###########################################

storage : context {

   : pattern {
      regex       \= $${__STORAGE}
      styles []   = .storage;
   }

}

###########################################
## Primitive Context
###########################################

primitive : context {

   : pattern {
      regex       \= ($${__NIL})
      styles []   = .nil;
   }

   : include "boolean" ;
   : include "numeric" ;
   : include "string" ;

}

###########################################
## Boolean Context
###########################################

boolean : context {

   : pattern {
      regex       \= ($${__TRUE})
      styles []   = .boolean_true;
   }

   : pattern {
      regex       \= ($${__FALSE})
      styles []   = .boolean_false;
   }

}

###########################################
## Numeric Context
###########################################

numeric : context {

   : pattern {
      regex     \= $${__FLOAT}
      styles [] = .float;
   }

   : pattern {
      regex     \= $${__INTEGER}
      styles [] = .integer;
   }

}

###########################################
## String Context
###########################################

string : context {

   : inline_push {
      regex         \= (\")
      styles []     = .string_start_punctuation;
      default_style = .text

      : pop {
         regex      \= (\")
         styles []  = .string_end_punctuation;
      }
   }

}

###########################################
## Identifier Context
###########################################

identifier : context {

   : pattern {
      regex     \= ($${__IDENTIFIER})
      styles [] = .identifier;
   }

}

###########################################
## JSX Context
###########################################

jsx_tag_attribute : context {

   : include "group_closure";

   : pattern {
      regex     \= (\s*)($${__IDENTIFIER})(\s*)$${__ASSIGN}(\s*(?!(?:$${__TRUE}|$${__FALSE}|$${__NIL})))($${__IDENTIFIER})
      styles [] = .whitespace, .jsx_property, .whitespace, .assignment_operator, .whitespace, .identifier;
   }

   : pattern {
      regex     \= (\s*)($${__IDENTIFIER})(\s*)$${__ASSIGN}(\s*)($${__TRUE})
      styles [] = .whitespace, .jsx_property, .whitespace, .assignment_operator, .whitespace, .boolean_true;
   }

   : pattern {
      regex     \= (\s*)($${__IDENTIFIER})(\s*)$${__ASSIGN}(\s*)($${__FALSE})
      styles [] = .whitespace, .jsx_property, .whitespace, .assignment_operator, .whitespace, .boolean_false;
   }

   : pattern {
      regex     \= (\s*)($${__IDENTIFIER})(\s*)$${__ASSIGN}(\s*)($${__NIL})
      styles [] = .whitespace, .jsx_property, .whitespace, .assignment_operator, .whitespace, .nil;
   }

   : pattern {
      regex     \= $${__ASSIGN}
      styles [] = .assignment_operator;
   }

   : include "primitive";

   : pattern {
      regex     \= ($${__IDENTIFIER})
      styles [] = .jsx_property;
   }

   : include "jsx";

}

jsx_fragment : context {

 : pattern {
      regex     \= (<\s*>)
      styles [] = .tag_begin_punctuation;
   }

   : pattern {
      regex     \= (<\s*/\s*>)
      styles [] = .tag_end_punctuation;
   }

}

jsx_inner : context {

   : include "block_closure";
   : include "jsx";

   : pattern {
      regex     \= ([^<{]+)
      styles [] = .jsx_text;
   }

}

jsx_ambiguity_guards : context {

   : pattern {
      regex     \= ($${__IDENTIFIER})(\s*)(<)(\s*)((?:$${__JSX_TAG}|$${__JSX_COMPONENT})(?!\s*(?:/\s*>|[>_a-zA-Z])))
      styles [] = .identifier, .whitespace, .relational_operator, .whitespace, .identifier;
   }

   : pattern {
      regex     \= $${__FLOAT}(\s*)(<)(\s*)((?:$${__JSX_TAG}|$${__JSX_COMPONENT})(?!\s*(?:/\s*>|[>_a-zA-Z])))
      styles [] = .float, .whitespace, .relational_operator, .whitespace, .identifier;
   }

   : pattern {
      regex     \= $${__INTEGER}(\s*)(<)(\s*)((?:$${__JSX_TAG}|$${__JSX_COMPONENT})(?!\s*(?:/\s*>|[>_a-zA-Z])))
      styles [] = .integer, .whitespace, .relational_operator, .whitespace, .identifier;
   }

}

jsx : context {

   : include "jsx_ambiguity_guards";

   : pattern {
      regex     \= (<)(\s*)($${__JSX_TAG})(\s*)(/\s*>)
      styles [] = .tag_begin_punctuation, .whitespace, .jsx_tag, .whitespace, .tag_end_punctuation;
   }

   : pattern {
      regex     \= (<)(\s*)($${__JSX_COMPONENT})(\s*)(/\s*>)
      styles [] = .tag_begin_punctuation, .whitespace, .jsx_component, .whitespace, .tag_end_punctuation;
   }

   : inline_push {
      regex     \= (<)(\s*)($${__JSX_TAG})(\s*)(>)
      styles [] = .tag_begin_punctuation, .whitespace, .jsx_tag, .whitespace, .tag_end_punctuation;

      : pop {
         regex     \= (<\s*/)(\s*)($${__JSX_TAG})(\s*)(>)
         styles [] = .tag_begin_punctuation, .whitespace, .jsx_tag, .whitespace, .tag_end_punctuation;
      }

      : include "jsx_inner";
   }

   : inline_push {
      regex     \= (<)(\s*)($${__JSX_COMPONENT})(\s*)(>)
      styles [] = .tag_begin_punctuation, .whitespace, .jsx_component, .whitespace, .tag_end_punctuation;

      : pop {
         regex     \= (<\s*/)(\s*)($${__JSX_COMPONENT})(\s*)(>)
         styles [] = .tag_begin_punctuation, .whitespace, .jsx_component, .whitespace, .tag_end_punctuation;
      }

      : include "jsx_inner";
   }

   : inline_push {
      regex          \= (<)(\s*)($${__JSX_TAG})
      styles []      = .tag_begin_punctuation, .whitespace, .jsx_tag;

      : pop {
         regex \= (?:($${__JSX_TAG}\s*)(>))|(/\s*>)
         styles [] = .jsx_tag, .tag_end_punctuation, .tag_end_punctuation;
      }

      : inline_push {
         regex          \= (>)
         styles []      = .tag_end_punctuation;

         : pop {
            regex \= (<\s*/)
            styles [] = .tag_begin_punctuation;
         }

         : include "jsx_inner";
      }

      : include "jsx_tag_attribute";
   }

   : inline_push {
      regex          \= (<)(\s*)($${__JSX_COMPONENT})
      styles []      = .tag_begin_punctuation, .whitespace, .jsx_component;

      : pop {
         regex \= (?:($${__JSX_COMPONENT}\s*)(>))|(/\s*>)
         styles [] = .jsx_component, .tag_end_punctuation, .tag_end_punctuation;
      }

      : inline_push {
         regex          \= (>)
         styles []      = .tag_end_punctuation;

         : pop {
            regex \= (<\s*/)
            styles [] = .tag_begin_punctuation;
         }

         : include "jsx_inner";
      }

      : include "jsx_tag_attribute";
   }

   : include "jsx_fragment";

}

###########################################
## Type Definition Context
###########################################

parameterized_type : context {

  : inline_push {
      regex       \= ([A-Z]\w*)(<)
      styles []   = .type_alias, .type_parameter_begin;

      : pop {
         regex       \= (>)
         styles []   = .type_parameter_end;
      }

      : pattern {
         regex     \= (\s*)(,)(\s*)
         styles [] = .whitespace, .punctuation, .whitespace;
      }

      : pattern {
         regex     \= (@)((?:/\w+)+)(#)([^>]+)
         styles [] = .text, .text, .punctuation, .identifier;
      }

      : pattern {
         regex     \= $${__PRIMITIVE_TYPE}
         styles [] = .primitive_type;
      }

      : pattern {
         regex     \= ([A-Z]\w*)
         styles [] = .type_alias;
      }

      : include "parameterized_type";
      : include "identifier";
   }

}

type_definition : context {

   : pattern {
      regex     \= ((?:$${__IDENTIFIER})?)(\s*)(:)(\s*)$${__PRIMITIVE_TYPE}
      styles [] = .variable_name, .whitespace, .typedef_punctuation, .whitespace, .primitive_type;
   }

   : pattern {
      regex     \= ((?:$${__IDENTIFIER})?)(\s*)(:)(\s*)([A-Z]\w+)
      styles [] = .variable_name, .whitespace, .typedef_punctuation, .whitespace, .type_alias;
   }

  : pattern {
      regex     \= $${__TYPE_STORAGE}(\s*)$${__PRIMITIVE_TYPE}
      styles [] = .type_storage, .whitespace, .primitive_type;
   }

   : pattern {
      regex     \= $${__TYPE_STORAGE}
      styles [] = .type_storage;
   }

}

###########################################
## Operator Context
###########################################

operator : context {

   : pattern {
      regex     \= $${__RELATIONAL}
      styles [] = .relational_operator;
   }

   : pattern {
      regex     \= $${__ARITHMETIC}
      styles [] = .arithmetic_operator;
   }

   : pattern {
      regex     \= $${__LOGIC}
      styles [] = .logical_operator;
   }

   : pattern {
      regex     \= $${__EQUALITY}
      styles [] = .equality_operator;
   }

   : pattern {
      regex    \= $${__ASSIGN}
      styles []   = .assignment_operator;
   }

}

###########################################
## Closure Context
###########################################

block_closure : context {

   : inline_push {
      regex     \= (\s*)({)(\s*)
      styles [] = .whitespace, .block_punctuation, .whitespace;

      : pop {
         regex     \= (\s*)(})(\s*)
         styles [] = .whitespace, .block_punctuation, .whitespace;
      }

      : include "main";
   }

}

group_closure : context {

   : inline_push {
      regex     \= (\s*)(\()(\s*)
      styles [] = .whitespace, .parenthese_punctuation, .whitespace;

      : pop {
         regex     \= (\s*)(\))(\s*)
         styles [] = .whitespace, .parenthese_punctuation, .whitespace;
      }

      : include "main";
   }

}

###########################################
## Punctuation Context
###########################################

punctuation : context {

   : pattern {
      regex     \= (;)
      styles [] = .terminal_punctuation;
   }

   : pattern {
      regex     \= (,)
      styles [] = .separator_punctuation;
   }

   : pattern {
      regex     \= (\(|\))
      styles [] = .parenthese_punctuation;
   }

   : pattern {
      regex     \= (\{|\})
      styles [] = .block_punctuation;
   }

   : pattern {
      regex     \= $${__PUNCTUATION}
      styles [] = .punctuation;
   }

}

whitespace : context {

   : pattern {
      regex     \= (\s+)
      styles [] = .whitespace;
   }

}

}
