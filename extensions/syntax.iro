#################################################################
## Iro
#################################################################

name                = knot
file_extensions []  = kn, knot;

################################################################
## Constants
################################################################

__ENTITY          \= const|view|func|state|style|let
__IDENTIFIER      \= [_a-zA-Z]\w*\b
__JSX_IDENTIFIER  \= [a-zA-Z]\w*\b
__IMPORT          \= \bimport\b
__FROM            \= \bfrom\b
__AS              \= \bas\b
__MAIN            \= \bmain\b
__TRUE            \= \btrue\b
__FALSE           \= \bfalse\b
__KEYWORDS        \= ($${__IMPORT}|$${__FROM}|$${__AS}|$${__MAIN})
__PRIMITIVE_TYPE  \= (\bstring\b|\bnumber\b|\bboolean\b)
__LOGIC           \= (\|\||&&|!)
__ARITHMETIC      \= ([+\-*/])
__RELATIONAL      \= (<=|>=|<|>)
__OPERATORS       \= (==|!=|[=~])
__PUNCTUATION     \= (</|/>|[:;<>])

################################################################
## Styles
################################################################

styles [] {

.comment : style {
   color          = grey
   italic         = true
   ace_scope      = comment
   textmate_scope = comment
}

.keyword : style {
   color          = pink
   ace_scope      = keyword.control
   textmate_scope = keyword.control
}

.main_keyword : style {
   color          = pink
   ace_scope      = keyword.control.main
   textmate_scope = keyword.control.main
}

.import_keyword : style {
   color          = pink
   ace_scope      = keyword.control.import
   textmate_scope = keyword.control.import
}

.from_keyword : style {
   color          = pink
   ace_scope      = keyword.control.from
   textmate_scope = keyword.control.from
}

.as_keyword : style {
   color          = pink
   ace_scope      = keyword.control.as
   textmate_scope = keyword.control.as
}

.storage : style {
   color          = red
   ace_scope      = storage.type
   textmate_scope = storage.type
}

.arrow : style {
   color          = red
   ace_scope      = storage.type.function.arrow
   textmate_scope = storage.type.function.arrow
}

.operator : style {
   color          = red
   ace_scope      = keyword.operator
   textmate_scope = keyword.operator
}

.logical_operator : style {
   color          = red
   ace_scope      = keyword.operator.logical
   textmate_scope = keyword.operator.logical
}

.arithmetic_operator : style {
   color          = red
   ace_scope      = keyword.operator.arithmetic
   textmate_scope = keyword.operator.arithmetic
}

.relational_operator : style {
   color          = red
   ace_scope      = keyword.operator.relational
   textmate_scope = keyword.operator.relational
}

.assignment_operator : style {
   color          = red
   ace_scope      = keyword.operator.assignment
   textmate_scope = keyword.operator.assignment
}

.numeric : style {
   color          = purple
   ace_scope      = constant.numeric.decimal
   textmate_scope = constant.numeric.decimal
}

.boolean_true : style {
   color          = purple
   ace_scope      = constant.language.boolean.true
   textmate_scope = constant.language.boolean.true
}

.boolean_false : style {
   color          = purple
   ace_scope      = constant.language.boolean.false
   textmate_scope = constant.language.boolean.false
}

.punctuation : style {
   color          = white
   ace_scope      = punctuation
   textmate_scope = punctuation
}

.import_all_punctuation : style {
   color          = white
   ace_scope      = constant.language.import-all
   textmate_scope = constant.language.import-all
}

.terminal_punctuation : style {
   color          = white
   ace_scope      = punctuation.terminal.statement
   textmate_scope = punctuation.terminal.statement
}

.separator_punctuation : style {
   color          = white
   ace_scope      = punctuation.separator.comma
   textmate_scope = punctuation.separator.comma
}

.string_start_punctuation : style {
   color          = yellow
   ace_scope      = punctuation.definition.string.begin
   textmate_scope = punctuation.definition.string.begin
}

.string_end_punctuation : style {
   color          = yellow
   ace_scope      = punctuation.definition.string.end
   textmate_scope = punctuation.definition.string.end
}

.parenthese_punctuation : style {
   color          = white
   ace_scope      = meta.brace.round
   textmate_scope = meta.brace.round
}

.block_punctuation : style {
   color          = white
   ace_scope      = punctuation.definition.block
   textmate_scope = punctuation.definition.block
}

.access_punctuation : style {
   color          = white
   ace_scope      = punctuation.accessor
   textmate_scope = punctuation.accessor
}

.typedef_punctuation : style {
   color          = white
   ace_scope      = keyword.operator.type.annotation
   textmate_scope = keyword.operator.type.annotation
}

.text : style {
   color          = gold
   ace_scope      = string.quoted.double
   textmate_scope = string.quoted.double
}

.entity_name : style {
   color          = green
   ace_scope      = entity.name
   textmate_scope = entity.name
}

.constant_name : style {
   color          = orange
   ace_scope      = variable.other.constant
   textmate_scope = variable.other.constant
}

.variable_name : style {
   color          = green
   ace_scope      = variable.other
   textmate_scope = variable.other
}

.function_name : style {
   color          = green
   ace_scope      = entity.name.function
   textmate_scope = entity.name.function
}

.import_name : style {
   color          = green
   ace_scope      = variable.other.alias
   textmate_scope = variable.other.alias
}

.identifier : style {
   color          = green
   ace_scope      = variable
   textmate_scope = variable
}

.injected : style {
   color          = orange
   ace_scope      = variable.parameter.injected
   textmate_scope = variable.parameter.injected
}

.type : style {
   color          = cyan
   ace_scope      = entity.name.type
   textmate_scope = entity.name.type
}

.primitive_type : style {
   color          = cyan
   ace_scope      = support.type.primitive
   textmate_scope = support.type.primitive
}

.jsx_tag : style {
   color          = red
   ace_scope      = entity.name.tag
   textmate_scope = entity.name.tag
}

.jsx_property : style {
   color          = light_blue
   ace_scope      = entity.other.attribute-name
   textmate_scope = entity.other.attribute-name
}

.whitespace : style ;

.illegal : style {
   color            = white
   background_color = red
   ace_scope        = invalid
   textmate_scope   = invalid
}

}

#################################################
## Parse contexts
#################################################

contexts [] {

##############################################
## Main Context - Entry point context
##############################################

main : context {

   : include "main_keyword" ;

   : include "import" ;

   : include "entity" ;

   : include "closure" ;

   : include "catch_all" ;

}

###########################################
## Closure Context
###########################################

closure : context {
   : inline_push {
      uid = uid_braces_closure
      regex         \= (\{)
      styles []     = .block_punctuation;

      : pop {
         regex      \= (\})
         styles []  = .block_punctuation;
      }

      : include "main" ;
   }

   : inline_push {
      uid = uid_parentheses_closure
      regex         \= (\()
      styles []     = .parenthese_punctuation;

      : pop {
         regex      \= (\))
         styles []  = .parenthese_punctuation;
      }

      : include "closure_list" ;
   }
}

closure_list : context {
   : include "closure" ;
   : include "catch_all" ;

   : pattern {
      regex      \= (,)
      styles []  = .separator_punctuation;
   }
}

###########################################
## Catch All Context
###########################################

catch_all : context {
   : include "keyword" ;
   : include "expression" ;
   : include "jsx" ;
   : include "type_definition" ;
   : include "comment" ;
   : include "operator" ;
   : include "punctuation" ;

   : pattern {
      regex     \= ([^\s])
      styles [] = .illegal;
   }
}

###########################################
## Keyword Context
###########################################

main_keyword : context {
   : pattern {
      regex     \= ($${__MAIN})
      styles [] = .main_keyword;
   }
}

###########################################
## Keyword Context
###########################################

keyword : context {
   : pattern {
      regex       \= $${__KEYWORDS}
      styles []   = .keyword;
   }
}

###########################################
## Operator Context
###########################################

operator : context {
   : pattern {
      regex     \= $${__RELATIONAL}
      styles [] = .relational_operator;
   }

   : pattern {
      regex       \= (->)
      styles []   = .arrow;
   }

  : pattern {
      regex     \= $${__ARITHMETIC}
      styles [] = .arithmetic_operator;
   }

   : pattern {
      regex     \= $${__LOGIC}
      styles [] = .logical_operator;
   }

   : pattern {
      regex    \= (=)
      styles []   = .assignment_operator;
   }

   : pattern {
      regex     \= $${__OPERATORS}
      styles [] = .operator;
   }
}

###########################################
## Punctuation Context
###########################################

punctuation : context {
   : pattern {
      regex     \= (;)
      styles [] = .terminal_punctuation;
   }

   : pattern {
      regex     \= (,)
      styles [] = .separator_punctuation;
   }

   : pattern {
      regex     \= (\.)
      styles [] = .access_punctuation;
   }

   : pattern {
      regex     \= (\(|\))
      styles [] = .parenthese_punctuation;
   }
   : pattern {
      regex     \= (\{|\})
      styles [] = .block_punctuation;
   }

   : pattern {
      regex     \= $${__PUNCTUATION}
      styles [] = .punctuation;
   }
}

###########################################
## Expression Context
###########################################

expression : context {
   : include "string" ;
   : include "numeric" ;
   : include "boolean" ;
   : include "function_call" ;
   : include "identifier" ;
}

###########################################
## Numeric Context
###########################################

numeric : context {
   : pattern {
      regex     \= (\B-\d+)|(\b\d+)
      styles [] = .numeric;
   }
}

###########################################
## Boolean Context
###########################################

boolean : context {
   : pattern {
      regex     \= ($${__TRUE})
      styles [] = .boolean_true;
   }

   : pattern {
      regex     \= ($${__FALSE})
      styles [] = .boolean_false;
   }
}

###########################################
## String Context
###########################################

string : context {
   : inline_push {
      regex         \= (\")
      styles []     = .string_start_punctuation;
      default_style = .text

      : pop {
         regex      \= (\")
         styles []  = .string_end_punctuation;
      }
   }
}

###########################################
## Type Definition Context
###########################################

type_definition : context {
   : pattern {
      regex     \= (:)(\s*)$${__PRIMITIVE_TYPE}
      styles [] = .typedef_punctuation, .whitespace, .primitive_type;
   }

   : pattern {
      regex     \= (:)(\s*)($${__IDENTIFIER})
      styles [] = .typedef_punctuation, .whitespace, .type;
   }
}

###########################################
## Function Call Context
###########################################

function_call : context {
   : inline_push {
      regex     \= (\b$${__IDENTIFIER})(\s*)(\()
      styles [] = .function_name, .whitespace, .punctuation;

      : pop {
         regex \= (\))
         styles [] = .punctuation;
      }

      : include "closure_list" ;
   }
}

###########################################
## Import Context
###########################################


import_closure : context {
   : inline_push {
      uid = uid_parentheses_import_closure
      regex         \= (\{)
      styles []     = .punctuation;

      : pop {
         regex      \= (\})
         styles []  = .punctuation;
      }

      : include "import_closure_list" ;
   }
}

import_closure_list : context {
   : pattern {
      regex      \= (,)
      styles []  = .separator_punctuation;
   }

   : pattern {
      regex       \= (\b$${__IDENTIFIER})
      styles []   = .import_name;
   }

   : include "main" ;
}


import : context {
   : inline_push {
      regex       \= ($${__IMPORT})(\s*)
      styles []   = .import_keyword, .whitespace;

      : pop {
         regex       \= ($${__FROM})
         styles []   = .from_keyword;
      }

      : include "import_closure";

      : pattern {
         regex       \= (\*)
         styles []   = .import_all_punctuation;
      }

      : pattern {
         regex       \= ($${__AS})
         styles []   = .as_keyword;
      }

      : pattern {
         regex       \= (\b$${__IDENTIFIER})
         styles []   = .import_name;
      }

      : include "main" ;
   }

   : pattern {
      regex       \= ($${__IMPORT})
      styles []   = .import_keyword;
   }
}

###########################################
## Entity Context
###########################################

entity : context {
   : pattern {
      regex       \= \b(func)(\s*)($${__IDENTIFIER})
      styles []   = .storage, .whitespace, .function_name;
   }

   : pattern {
      regex       \= \b(const)(\s*)($${__IDENTIFIER})
      styles []   = .storage, .whitespace, .constant_name;
   }

   : pattern {
      regex       \= \b(let)(\s*)($${__IDENTIFIER})
      styles []   = .storage, .whitespace, .variable_name;
   }

   : pattern {
      regex       \= \b($${__ENTITY})(\s*)($${__IDENTIFIER})
      styles []   = .storage, .whitespace, .entity_name;
   }
}

###########################################
## Identifier Context
###########################################

identifier : context {
   : pattern {
      regex     \= (\B\$$${__IDENTIFIER})
      styles [] = .injected;
   }

   : pattern {
      regex     \= (\b$${__IDENTIFIER})
      styles [] = .identifier;
   }
}

###########################################
## JSX Context
###########################################

jsx : context {
   : pattern {
      uid = uid_end_tag_jsx
      regex \= (</)(\s*)($${__JSX_IDENTIFIER})(\s*)(>)
      styles [] = .punctuation, .whitespace, .jsx_tag, .whitespace, .punctuation;
   }

   : inline_push {
      uid = uid_self_closing_jsx
      regex     \= (<)(\s*)($${__JSX_IDENTIFIER})
      styles [] = .punctuation, .whitespace, .jsx_tag;

      : pop {
         regex \= (/>|>)
         styles [] = .punctuation;
      }

      : pattern {
         regex \= (\b$${__IDENTIFIER})(\s*)(=)(\s*)(\"[^"]*\")
         styles [] = .jsx_property, .whitespace, .punctuation, .whitespace, .text;
      }

      : inline_push {
         regex \= (\b$${__IDENTIFIER})(\s*)(=)(\s*)({)
         styles [] = .jsx_property, .whitespace, .punctuation, .whitespace, .punctuation;

         : pop {
            regex \= (})
            styles [] = .punctuation;
         }

         : include "main";
      }

      : pattern {
         regex \= (\b$${__IDENTIFIER})
         styles [] = .jsx_property;
      }
   }
}

###########################################
## Multi Line Comment Context
###########################################

comment : context {
   : inline_push {
      uid = uid_block_comment
      regex         \= (/\*)
      styles []     = .comment;
      default_style = .comment

      : pop {
         regex      \= (\*/)
         styles []  = .comment;
      }
   }

   : pattern {
      uid = uid_line_comment
      regex     \= (//.*)
      styles [] = .comment;
   }
}

}

#################################################
## End of Contexts
#################################################
