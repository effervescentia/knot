--- ./myocamlbuild.ml
+++ ./myocamlbuild.ml
@@ -107,7 +107,7 @@
 ;;
 
 (* OASIS_START *)
-(* DO NOT EDIT (digest: abd4c3624ec7c742aae7dbd96c89cd14) *)
+(* DO NOT EDIT (digest: f54b1f8d97dfa848f6d79c1c3a40cf79) *)
 module OASISGettext = struct
 # 22 "src/oasis/OASISGettext.ml"
 
@@ -279,6 +279,28 @@
     else
       s
 
+  let exists f str =
+    let rec iter i =
+      if i < 0 then
+        false
+      else if f str.[i] then
+        true
+      else
+        iter (pred i)
+    in
+      iter (String.length str - 1)
+
+  let is_digit c =
+    '0' <= c && c <= '9'
+
+  let is_alpha c =
+    ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')
+
+  let is_whitespace =
+    function
+      | ' ' | '\r' | '\n' | '\t' -> true
+      |  _  -> false
+
 end
 
 module OASISUtils = struct
@@ -542,7 +564,7 @@
 end
 
 
-# 437 "myocamlbuild.ml"
+# 459 "myocamlbuild.ml"
 module BaseEnvLight = struct
 # 22 "src/base/BaseEnvLight.ml"
 
@@ -622,7 +644,7 @@
 end
 
 
-# 517 "myocamlbuild.ml"
+# 539 "myocamlbuild.ml"
 module MyOCamlbuildFindlib = struct
 # 22 "src/plugins/ocamlbuild/MyOCamlbuildFindlib.ml"
 
@@ -699,7 +721,9 @@
     with Not_found -> s
 
   (* ocamlfind command *)
-  let ocamlfind x = S[Sh (exec_from_conf "ocamlfind"); x]
+  let ocamlfind x = S[Sh (
+    Ocamlbuild_pack.Shell.quote_filename_if_needed
+      (exec_from_conf "ocamlfind") ); x]
 
   (* This lists all supported packages. *)
   let find_packages () =
@@ -983,7 +1007,7 @@
 end
 
 
-# 878 "myocamlbuild.ml"
+# 902 "myocamlbuild.ml"
 open Ocamlbuild_plugin;;
 let package_default =
   {
@@ -1283,7 +1307,7 @@
 
 let dispatch_default = MyOCamlbuildBase.dispatch_default conf package_default;;
 
-# 1179 "myocamlbuild.ml"
+# 1203 "myocamlbuild.ml"
 (* OASIS_STOP *)
 
 open Ocamlbuild_plugin;;
--- ./setup.ml
+++ ./setup.ml
@@ -21,9 +21,9 @@
 (******************************************************************************)
 
 (* OASIS_START *)
-(* DO NOT EDIT (digest: 6bf336bd3a817bf7523ab66c3f46186c) *)
+(* DO NOT EDIT (digest: 4859873bfec85860f75d16694b510ed0) *)
 (*
-   Regenerated by OASIS v0.4.11~HEAD
+   Regenerated by OASIS v0.4.10
    Visit http://oasis.forge.ocamlcore.org for more information and
    documentation about functions used in this file.
 *)
@@ -198,6 +198,28 @@
     else
       s
 
+  let exists f str =
+    let rec iter i =
+      if i < 0 then
+        false
+      else if f str.[i] then
+        true
+      else
+        iter (pred i)
+    in
+      iter (String.length str - 1)
+
+  let is_digit c =
+    '0' <= c && c <= '9'
+
+  let is_alpha c =
+    ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')
+
+  let is_whitespace =
+    function
+      | ' ' | '\r' | '\n' | '\t' -> true
+      |  _  -> false
+
 end
 
 module OASISUtils = struct
@@ -473,6 +495,118 @@
 
   module Unix = OASISUnixPath
 
+  let bash_cmd = ref ( fun () -> "" )
+
+  let use_bash () = ( !bash_cmd () ) <> ""
+
+
+  (* generic quote and unixquote are taken from ocaml source *)
+  let generic_quote quotequote s =
+    let l = String.length s in
+    let b = Buffer.create (l + 20) in
+      Buffer.add_char b '\'';
+      for i = 0 to l - 1 do
+        if s.[i] = '\'' then
+          Buffer.add_string b quotequote
+        else
+          Buffer.add_char b  s.[i]
+      done;
+      Buffer.add_char b '\'';
+      Buffer.contents b
+
+  let unixquote = generic_quote "'\\''"
+
+  let win = Sys.os_type = "Win32"
+
+  let quote str =
+    if win && use_bash () then
+      unixquote str
+    else
+      quote str
+
+  (* uniform_path (only called, if Sys.os_type = "Win32")
+   * - enforces uniform path seperators
+   * - strips trailing slashes (exceptions in case of C:\ and / )
+   * - removes (some) unnecessary file components like ./././
+   *)
+
+  let get_naccu accu str first pos =
+    (* I assume c//d is identic to c/d
+     * the only exception (Network devices \\xyz\asdf)
+     * is covered in uniform_path
+     *)
+    if first = pos then
+      accu
+    else
+      let nlen = pos - first in
+      let nstr = String.sub str first nlen in
+        (* test/././ is the same as test *)
+        if nlen = 1 && nstr = "." then
+          accu
+        (* a/b/../ is the same as a *)
+        else if nlen = 2 && nstr = ".." then
+          match accu with
+            | []      -> [ nstr ]
+            | ".."::_ -> nstr::accu
+            | hd::tl  -> tl
+        else
+          nstr::accu
+
+  let is_path_sep = function
+    | '\\' | '/' -> true
+    | _ -> false
+
+
+  let uniform_path path_sep = function
+    | "" -> "" (* Raise an exception? Or an possible intermediate result?
+               * Filename.basename and dirname also don't raise exceptions *)
+    | str ->
+        let rec iter accu str len first pos =
+          if pos >= len then
+            List.rev (get_naccu accu str first pos)
+          else
+            let next = succ pos in
+              match is_path_sep str.[pos] with
+                | true -> iter (get_naccu accu str first pos) str len next next
+                | false -> iter accu str len first next
+        in
+          let is_unix_root = is_path_sep str.[0] in
+          let len = String.length str in
+          let next_sep = len > 1 && is_path_sep str.[1] in
+          let is_network_root = is_unix_root && next_sep in
+          let is_currel = str.[0] = '.' && ( next_sep || len = 1 ) in
+          let l = iter [] str len 0 0 in
+          (* Trailing slashes are normally stripped.
+           * This is not possible in case of root folders
+           * Sys.file_exists "C:" is false, Sys.file_exists "C:\\" true
+           *)
+          let l_min =
+            match l with
+              | [] -> [ "" ]
+              | _ -> l
+          in
+          let l =
+            if is_network_root then
+              ""::""::l_min
+            else if is_unix_root then
+              ""::l_min
+            else if is_currel then
+              "."::l
+            else
+              match l with
+                | s :: [] ->
+                    (* root folders like C:\ *)
+                    if String.length s = 2 && s.[1] = ':' &&
+                      len > 2 && is_path_sep str.[2]
+                    then
+                      s :: [ "" ]
+                    else
+                      l
+                | _ -> l
+          in
+            String.concat path_sep l
+
+
 
   let make =
     function
@@ -486,22 +620,31 @@
     match Sys.os_type with
     | "Unix" | "Cygwin" -> ufn
     | "Win32" ->
-      make
-        (List.map
-           (fun p ->
-              if p = Unix.current_dir_name then
-                current_dir_name
-              else if p = Unix.parent_dir_name then
-                parent_dir_name
+      let path_sep =
+        if use_bash () then
+          "/"
               else
-                p)
-           (OASISString.nsplit ufn '/'))
+          "\\"
+      in
+      uniform_path path_sep ufn
     | os_type ->
       OASISUtils.failwithf
         (f_ "Don't know the path format of os_type %S when translating unix \
              filename. %S")
         os_type ufn
 
+  (* see findlib's src/findlib/frontend.ml for details *)
+  let ocamlfind_unquote dir =
+    match Sys.os_type with
+    | "Cygwin"
+    | "Win32" ->
+      let len = String.length dir in
+      if len < 3 || dir.[0] <> '"' || dir.[len - 1] <> '"' ||
+         String.contains dir ' ' = false then
+        dir
+      else
+        String.sub dir 1 (len - 2)
+    | _ -> dir
 
 end
 
@@ -1084,8 +1227,8 @@
 
 
   (* Range of allowed characters *)
-  let is_digit c = '0' <= c && c <= '9'
-  let is_alpha c = ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')
+  let is_digit = OASISString.is_digit
+  let is_alpha = OASISString.is_alpha
   let is_special = function | '.' | '+' | '-' | '~' -> true | _ -> false
 
 
@@ -2513,6 +2656,7 @@
       ~ctxt
       ~is_native
       ~source_file_exists
+      ~ext_obj
       (cs, bs, obj) =
 
     let find_module ext modul =
@@ -2526,12 +2670,12 @@
         | [ m ] -> (find_module ".cmi" m,
             find_module ".cmo" m,
             find_module ".cmx" m,
-            find_module ".o" m,
+            find_module ext_obj m,
             fun x -> x)
         | _ -> ([cs.cs_name ^ ".cmi"],
             [cs.cs_name ^ ".cmo"],
             [cs.cs_name ^ ".cmx"],
-            [cs.cs_name ^ ".o"],
+            [cs.cs_name ^ ext_obj],
             OASISUnixPath.concat bs.bs_path)
     in
     List.map (List.map f) (
@@ -2891,26 +3035,170 @@
   open OASISUtils
   open OASISMessage
 
+  let is_dubious_char = function
+    | '+' | '~' | ':' | '.' | '-' | '_' | '/' | '\\' -> false
+    | c ->
+      OASISString.is_digit c = false &&
+      OASISString.is_alpha c = false
+
+
+  let win_quote_needed str =
+    let f = function
+      | 'a' .. 'z'  | 'A' .. 'Z' | '0' .. '9'
+      | '_' | '-' | '~' | '.' | ':' | ',' | '\\' -> false
+      | _ -> true
+    in
+      str = "" || OASISString.exists f str
+
+  let is_simple_command str =
+    String.length str > 0 &&
+    not (OASISString.exists is_dubious_char str)
+
+  let is_path_sep = function
+    | '/' | '\\' -> true
+    | _ -> false
+
+  let starts_with_absolute_path cmd =
+    let len = String.length cmd in
+      if len < 3 then
+        false
+      else
+        let c0 = cmd.[0] in
+        let c1 = cmd.[1] in
+          if is_path_sep c0 && is_path_sep c1 then (* network devices: "//" *)
+            true
+          else if len = 3 then
+            false
+          else  (* C:\.... *)
+            OASISString.is_alpha c0 && c1 = ':' && is_path_sep cmd.[2]
 
-  (* TODO: I don't like this quote, it is there because $(rm) foo expands to
-   * 'rm -f' foo...
-  *)
-  let run ~ctxt ?f_exit_code ?(quote=true) cmd args =
+  let exe_exts = lazy
+    begin
+      let exts =
+        try
+          OASISString.nsplit
+            (Sys.getenv "PATHEXT")
+            ';'
+        with
+          | Not_found -> []
+      in
+      let exts' =
+        List.filter
+          ( fun a -> a <> "" && a.[0] = '.' && a <> ".exe" )
+          (List.map OASISString.lowercase_ascii exts)
+      in
+        ".exe"::exts'
+    end
+
+  let exe_file_exists fln =
+    Sys.file_exists fln ||
+    List.exists
+      (fun a -> Sys.file_exists ( fln ^ a ) )
+      (Lazy.force exe_exts)
+
+
+  let quote_anyway cmd =
+    if Sys.os_type <> "Win32" then
+      false
+    else if is_simple_command cmd then
+      true
+    else
+      OASISString.exists OASISString.is_whitespace cmd &&
+        starts_with_absolute_path cmd &&
+        exe_file_exists cmd
+
+
+  let run_bash ~ctxt ?f_exit_code ?(quote=true) cmd args =
+    let fn = Filename.temp_file "oasis-" ".sh" in
+    let fn_deleted = ref false in
+      try
+        begin
+          let ch = open_out_bin fn in
+          let ch_closed = ref false in
+            try
+              begin
     let cmd =
-      if quote then
-        if Sys.os_type = "Win32" then
-          if String.contains cmd ' ' then
-            (* Double the 1st double quote... win32... sigh *)
-            "\""^(Filename.quote cmd)
+                  if quote || quote_anyway cmd then
+                    OASISHostPath.quote (OASISHostPath.of_unix cmd)
+                  else
+                    cmd
+                in
+                  output_string ch cmd;
+                  List.iter
+                    ( fun s -> output_char ch ' '; output_string ch s )
+                    args ;
+                  output_char ch '\n';
+                  ch_closed:=true ;
+                  close_out ch;
+                  let bash = !OASISHostPath.bash_cmd () in
+                  let add_quotes = ref false in
+                  let shell_cmd =
+                    if Sys.os_type <> "Win32" then
+                      Filename.quote bash
+                    else
+                      if win_quote_needed bash = false then
+                        bash
+                      else
+                        begin
+                          add_quotes := true;
+                          Filename.quote bash
+                        end
+                  in
+                  let cmdline_orig = String.concat " " (cmd :: args) in
+                  let cmdline =
+                    let s = shell_cmd ^ " " ^ (Filename.quote fn) in
+                      if !add_quotes then
+                        "\"" ^ s ^ "\""
           else
+                        s
+                  in
+                    info ~ctxt (f_ "Running command '%s'") cmdline_orig;
+                    let ret = Sys.command cmdline in
+                      fn_deleted := true;
+                      Sys.remove fn;
+                      match f_exit_code, ret with
+                        | None, 0 -> ()
+                        | None, i ->
+                            failwithf
+                              (f_ "Command '%s' terminated with error code %d")
+                              cmdline_orig i
+                        | Some f, i ->
+                            f i
+              end
+            with
+              | x when !ch_closed = false ->
+                  close_out_noerr ch;
+                  raise x
+        end
+      with
+        | x when !fn_deleted = false ->
+            (try Sys.remove fn with _ -> () ) ;
+            raise x
+
+  let run_default ~ctxt ?f_exit_code ?(quote=true) cmd args =
+    let add_quotes = ref false in
+    let cmd =
+      if quote || quote_anyway cmd then
+        if Sys.os_type = "Win32" then
+          begin
+            if win_quote_needed cmd = false then
             cmd
         else
+              begin
+                add_quotes := true;
+                Filename.quote cmd
+              end
+          end
+        else
           Filename.quote cmd
       else
         cmd
     in
     let cmdline =
-      String.concat " " (cmd :: args)
+      let s = String.concat " " (cmd :: args) in
+        match !add_quotes with
+          | true -> "\"" ^ s ^ "\""
+          | false -> s
     in
     info ~ctxt (f_ "Running command '%s'") cmdline;
     match f_exit_code, Sys.command cmdline with
@@ -2922,6 +3210,13 @@
       | Some f, i ->
         f i
 
+  let run ~ctxt ?f_exit_code ?quote cmd args =
+    if OASISHostPath.use_bash () &&
+       (Sys.os_type <> "Win32" || not (Filename.check_suffix cmd ".bat"))
+    then
+      run_bash ~ctxt ?f_exit_code ?quote cmd args
+    else
+      run_default ~ctxt ?f_exit_code ?quote cmd args
 
   let run_read_output ~ctxt ?f_exit_code cmd args =
     let fn =
@@ -3032,7 +3327,7 @@
     ) alternatives
 
 
-  let which ~ctxt prg =
+  let which ?(plain=false) ?ctxt prg =
     let path_sep =
       match Sys.os_type with
         | "Win32" ->
@@ -3044,11 +3339,19 @@
     let exec_ext =
       match Sys.os_type with
         | "Win32" ->
-          "" :: (OASISString.nsplit (Sys.getenv "PATHEXT") path_sep)
+          "" :: (List.map
+                   OASISString.lowercase_ascii
+                   (OASISString.nsplit (Sys.getenv "PATHEXT") path_sep))
         | _ ->
           [""]
     in
+    let p =
     find_file ~case_sensitive:false [path_lst; [prg]] exec_ext
+    in
+    if plain then
+      p
+    else
+      OASISHostPath.of_unix p
 
 
   (**/**)
@@ -3065,35 +3368,54 @@
       dn
 
 
-  let q = Filename.quote
+  let q s = OASISHostPath.quote (OASISHostPath.of_unix s)
   (**/**)
 
-
   let cp ~ctxt ?(recurse=false) src tgt =
     if recurse then
-      match Sys.os_type with
-        | "Win32" ->
-          OASISExec.run ~ctxt
-            "xcopy" [q src; q tgt; "/E"]
-        | _ ->
-          OASISExec.run ~ctxt
-            "cp" ["-r"; q src; q tgt]
+      (*
+        'xcopy /E' and 'cp -r' don't have the same semantic!
+        -dir2 does exist:
+          xcopy dir dir2 /E -> copys content of dir into dir2 (dir2/dir doesn't exist!)
+          cp -r dir dir2    -> copys dir to dir2 (dir2/dir does exist!)
+        -dir2 doesn't exist:
+          xcopy dir dir2 /E -> request on command line, if dir2 is an directory or file.
+          cp -r dir dir2    -> dir and dir2 have the same content (dir2/dir doesn't exist)
+        Probably, there are even more differences,....
+      *)
+      if Sys.os_type = "Win32" && OASISHostPath.use_bash () = false then
+        let tgt_real =
+          if Sys.file_exists tgt = false then
+            begin
+              OASISExec.run ~ctxt "md" [q tgt];
+              tgt
+            end
     else
-      OASISExec.run ~ctxt
-        (match Sys.os_type with
-          | "Win32" -> "copy"
-          | _ -> "cp")
-        [q src; q tgt]
-
+            let base = Filename.basename src in
+            if base = "." then
+              tgt
+            else
+              let tgt_real = Filename.concat tgt base in
+              if Sys.file_exists tgt_real = false then
+                OASISExec.run ~ctxt "md" [q tgt_real];
+              tgt_real
+        in
+        OASISExec.run ~ctxt "xcopy" [q src; q tgt_real; "/E" ; "/Q" ; "/Y"]
+      else
+        OASISExec.run ~ctxt "cp" ["-r"; q src; q tgt]
+    else if Sys.os_type = "Win32" && OASISHostPath.use_bash () = false then
+      OASISExec.run ~ctxt "copy" [q src; q tgt ; "/Y"]
+    else
+      OASISExec.run ~ctxt "cp" [q src; q tgt]
 
   let mkdir ~ctxt tgt =
     OASISExec.run ~ctxt
-      (match Sys.os_type with
-        | "Win32" -> "md"
-        | _ -> "mkdir")
+      ( if Sys.os_type = "Win32" && not (OASISHostPath.use_bash ()) then
+          "md"
+        else
+          "mkdir" )
       [q tgt]
 
-
   let rec mkdir_parent ~ctxt f tgt =
     let tgt =
       fix_dir tgt
@@ -3119,10 +3441,9 @@
 
   let rmdir ~ctxt tgt =
     if Sys.readdir tgt = [||] then begin
-      match Sys.os_type with
-        | "Win32" ->
+      if Sys.os_type = "Win32" && OASISHostPath.use_bash () = false then
           OASISExec.run ~ctxt "rd" [q tgt]
-        | _ ->
+      else
           OASISExec.run ~ctxt "rm" ["-r"; q tgt]
     end else begin
       OASISMessage.error ~ctxt
@@ -3176,7 +3497,7 @@
 end
 
 
-# 3159 "setup.ml"
+# 3480 "setup.ml"
 module BaseEnvLight = struct
 # 22 "src/base/BaseEnvLight.ml"
 
@@ -3256,7 +3577,7 @@
 end
 
 
-# 3239 "setup.ml"
+# 3560 "setup.ml"
 module BaseContext = struct
 # 22 "src/base/BaseContext.ml"
 
@@ -3347,7 +3668,7 @@
   let var_lxr = Genlex.make_lexer []
 
 
-  let rec var_expand str =
+  let rec var_expand ?(quoted=false) str =
     let buff =
       Buffer.create ((String.length str) * 2)
     in
@@ -3375,7 +3696,11 @@
              | [Genlex.Ident "ocaml_escaped"; Genlex.String s] ->
                String.escaped s
              | [Genlex.Ident nm] ->
-               var_get nm
+                 let s = var_get nm in
+                 if quoted then
+                   OASISHostPath.quote s
+                 else
+                   s
              | _ ->
                failwithf
                  (f_ "Unknown expression '%s' in variable expansion of %s.")
@@ -3913,9 +4238,11 @@
     in
     let findlib_dir pkg =
       let dir =
+        OASISHostPath.of_unix (
+          OASISHostPath.ocamlfind_unquote (
         OASISExec.run_read_one_line ~ctxt:!BaseContext.default
           (ocamlfind ())
-          ["query"; "-format"; "%d"; pkg]
+              ["query"; "-format"; "%d"; pkg] ) )
       in
       if Sys.file_exists dir && Sys.is_directory dir then
         dir
@@ -4045,6 +4372,9 @@
       match nm with
         | "ocaml_version" ->
           "version", chop_version_suffix
+        | "standard_library"
+        | "standard_library_default" ->
+            nm, ( fun x -> OASISHostPath.of_unix x)
         | _ -> nm, (fun x -> x)
     in
     var_redefine
@@ -4184,15 +4514,43 @@
 
 
   let (/) a b =
-    if os_type () = Sys.os_type then
+    let os = os_type () in
+    if os = Sys.os_type then
+      if Sys.os_type = "Win32" && OASISHostPath.use_bash () then
+        OASISUnixPath.concat a b
+      else
       Filename.concat a b
-    else if os_type () = "Unix" || os_type () = "Cygwin" then
+    else if os = "Unix" || os = "Cygwin" then
       OASISUnixPath.concat a b
     else
-      OASISUtils.failwithf (f_ "Cannot handle os_type %s filename concat")
-        (os_type ())
+      OASISUtils.failwithf (f_ "Cannot handle os_type %s filename concat") os
   (**/**)
 
+  let auto_bash =
+    lazy (
+      try
+        let bash = OASISFileUtil.which ~plain:true "bash" in
+        let sh = Filename.concat (Filename.dirname bash) "sh.exe" in
+        if Sys.file_exists sh then
+          sh
+        else
+          bash
+      with
+      | Not_found | Sys_error _ -> "" )
+
+  let auto_bash () =
+    if Sys.os_type <> "Win32" then
+      ""
+    else
+      Lazy.force auto_bash
+
+  let bash_cmd =
+    var_define
+     ~short_desc:(fun () -> s_ "Enforced bash shell:")
+      ~cli:CLIAuto
+      ~arg_help:"program"
+      "use_bash"
+      auto_bash
 
   let prefix =
     p "prefix"
@@ -4200,10 +4558,30 @@
       (fun () ->
          match os_type () with
            | "Win32" ->
+            let getenv w =
+              try
+                Some(Sys.getenv w)
+              with
+              | Not_found -> None
+            in
+            let s =
+              if Sys.word_size = 64 then
+                getenv "ProgramW6432"
+              else
+                None
+            in
+            let s =
+              if s = None then
+                getenv "PROGRAMFILES"
+              else
+                s
+            in
              let program_files =
-               Sys.getenv "PROGRAMFILES"
+              match s with
+              | None -> "C:\\Program Files"
+              | Some x -> x
              in
-             program_files/(pkg_name ())
+            OASISHostPath.of_unix (program_files/(pkg_name ()))
            | _ ->
              "/usr/local")
 
@@ -4289,7 +4667,15 @@
   let docdir =
     p "docdir"
       (fun () -> s_ "Documentation root")
-      (fun () -> "$datarootdir"/"doc"/"$pkg_name")
+      (fun () ->
+        (* TODO: (Windows only?) "$pkg_name" is not always substituted
+         * (at least if datarootdir contains spaces or other garbage)
+         * I haven't looked up why.
+         *)
+        match os_type () with
+          | "Win32" -> "$datarootdir"/"doc"/ ( pkg_name () )
+          | _ -> "$datarootdir"/"doc"/"$pkg_name"
+      )
 
 
   let htmldir =
@@ -4363,9 +4749,10 @@
       ~short_desc:(fun () -> s_ "Remove a file.")
       "rm"
       (fun () ->
-         match os_type () with
-           | "Win32" -> "del"
-           | _ -> "rm -f")
+         if not (OASISHostPath.use_bash ()) && os_type () = "Win32" then
+           "del"
+         else
+           "rm -f" )
 
 
   let rmdir =
@@ -4373,9 +4760,10 @@
       ~short_desc:(fun () -> s_ "Remove a directory.")
       "rmdir"
       (fun () ->
-         match os_type () with
-           | "Win32" -> "rd"
-           | _ -> "rm -rf")
+         if not (OASISHostPath.use_bash ()) && os_type () = "Win32" then
+           "rd"
+         else
+           "rm -rf")
 
 
   let debug =
@@ -4439,14 +4827,26 @@
            let has_native_dynlink =
              let ocamlfind = ocamlfind () in
              try
-               let fn =
+               (* -format %d/%a doesn't work, because ocamlfind quotes %d
+                  * and %a separatly *)
+               let fn1 =
+                 OASISHostPath.ocamlfind_unquote (
+                   OASISExec.run_read_one_line
+                     ~ctxt:!BaseContext.default
+                     ocamlfind
+                     ["query"; "-predicates"; "native"; "dynlink";
+                      "-format"; "%d"] )
+               in
+               let fn2 =
+                 OASISHostPath.ocamlfind_unquote (
                  OASISExec.run_read_one_line
                    ~ctxt:!BaseContext.default
                    ocamlfind
                    ["query"; "-predicates"; "native"; "dynlink";
-                    "-format"; "%d/%a"]
+                      "-format"; "%a"]
+                 )
                in
-               Sys.file_exists fn
+               fn1 <> "" && fn2 <> "" && Sys.file_exists (Filename.concat fn1 fn2)
              with _ ->
                false
            in
@@ -4473,6 +4873,8 @@
     rpkg := Some pkg;
     List.iter (fun f -> f pkg.oasis_version) !var_cond
 
+  let () =
+    OASISHostPath.bash_cmd := bash_cmd
 end
 
 module BaseFileAB = struct
@@ -4748,6 +5150,7 @@
         ~source_file_exists:(fun fn ->
           OASISFileUtil.file_exists_case (OASISHostPath.of_unix fn))
         ~is_native:(bool_of_string (is_native ()))
+        ~ext_obj:(ext_obj())
         (cs, bs, obj)
     in
     let evs =
@@ -4773,7 +5176,7 @@
     OASISExec.run ~ctxt:!BaseContext.default ~quote:false
       (var_expand cmd)
       (List.map
-         var_expand
+         (var_expand ~quoted:true)
          (args @ (Array.to_list extra_args)))
 
 
@@ -5047,9 +5450,27 @@
 
   let configure ~ctxt t args =
     (* Run configure *)
+
+    (* use-bash is an exception. It's already needed to run the
+       pre-configure script. *)
+    let rec f = function
+      | [] ->
+        begin
+          try
+            let x = Sys.getenv "USE_BASH" in
+              OASISHostPath.bash_cmd := (fun () -> x);
+          with
+            _ -> ()
+        end
+      | "--use-bash"::x::_ ->
+          OASISHostPath.bash_cmd := (fun () -> x);
+      | _::tl -> f tl
+    in
+      f (Array.to_list args);
     BaseCustom.hook
       t.package.conf_custom
       (fun () ->
+           OASISHostPath.bash_cmd := BaseStandardVar.bash_cmd;
          (* Reload if preconf has changed it *)
          begin
            try
@@ -5679,7 +6100,7 @@
 end
 
 
-# 5662 "setup.ml"
+# 6083 "setup.ml"
 module InternalConfigurePlugin = struct
 # 22 "src/plugins/internal/InternalConfigurePlugin.ml"
 
@@ -5959,12 +6380,21 @@
   let install_findlib_ev = "install-findlib"
 
 
-  (* TODO: this can be more generic and used elsewhere. *)
-  let win32_max_command_line_length = 8000
-
-
   let split_install_command ocamlfind findlib_name meta files =
-    if Sys.os_type = "Win32" then
+    if Sys.os_type <> "Win32" then
+      ["install" :: findlib_name :: meta :: files]
+    else
+      let f s =
+        OASISHostPath.quote ( OASISHostPath.of_unix s )
+      in
+      let files = List.map f files in
+      let meta = f meta  in
+      let win32_max_command_line_length =
+        if OASISHostPath.use_bash () = false then
+          7900
+        else
+          30000
+      in
       (* Arguments for the first command: *)
       let first_args = ["install"; findlib_name; meta] in
       (* Arguments for remaining commands: *)
@@ -6022,10 +6452,11 @@
                     let cmds = split other_args others in
                     cmd :: cmds
       in
+      if files = [] then
+        [ first_args ]
+      else
       (* The first command does not use -add: *)
       split first_args files
-    else
-      ["install" :: findlib_name :: meta :: files]
 
 
   let install =
@@ -6446,7 +6877,10 @@
       if ev = install_file_ev then begin
         if OASISFileUtil.file_exists_case data then begin
           info (f_ "Removing file '%s'") data;
-          Sys.remove data
+          (try Sys.remove data
+          with Sys_error _ when
+              Sys.os_type = "Win32" &&
+              Filename.basename data = "setup.ml" -> ());
         end else begin
           warning (f_ "File '%s' doesn't exist anymore") data
         end
@@ -6482,7 +6916,7 @@
 end
 
 
-# 6465 "setup.ml"
+# 6899 "setup.ml"
 module OCamlbuildCommon = struct
 # 22 "src/plugins/ocamlbuild/OCamlbuildCommon.ml"
 
@@ -6497,11 +6931,7 @@
   open OASISTypes
 
 
-  type args =
-    {
-      plugin_tags: string option;
-      extra: string list;
-    }
+  type extra_args = string list
 
 
   let ocamlbuild_clean_ev = "ocamlbuild-clean"
@@ -6543,14 +6973,7 @@
           ]
         else
           [];
-
-        args.extra;
-
-        begin
-          match args.plugin_tags with
-          | Some t -> ["-plugin-tag"; Filename.quote t]
-          | None -> []
-        end;
+        args;
 
         if bool_of_string (debug ()) then
           ["-tag"; "debug"]
@@ -6581,9 +7004,7 @@
     (* Run if never called with these args *)
     if not (BaseLog.exists ~ctxt ocamlbuild_clean_ev extra_cli) then
       begin
-        OASISExec.run
-          ~ctxt (ocamlbuild ())
-          (fix_args {extra = ["-clean"]; plugin_tags = None} extra_argv);
+        OASISExec.run ~ctxt (ocamlbuild ()) (fix_args ["-clean"] extra_argv);
         BaseLog.register ~ctxt ocamlbuild_clean_ev extra_cli;
         at_exit
           (fun () ->
@@ -6615,7 +7036,7 @@
         | [] ->
           dir
     in
-    search_args "_build" (fix_args {extra = []; plugin_tags = None} extra_argv)
+    search_args "_build" (fix_args [] extra_argv)
 
 
 end
@@ -6641,7 +7062,7 @@
   let cond_targets_hook = ref (fun lst -> lst)
 
 
-  let build ~ctxt args pkg argv =
+  let build ~ctxt extra_args pkg argv =
     (* Return the filename in build directory *)
     let in_build_dir fn =
       Filename.concat
@@ -6789,14 +7210,14 @@
     (* Run a list of target... *)
     run_ocamlbuild
       ~ctxt
-      {args with extra = List.flatten (List.map snd cond_targets) @ args.extra}
+      (List.flatten (List.map snd cond_targets) @ extra_args)
       argv;
     (* ... and register events *)
     List.iter check_and_register (List.flatten (List.map fst cond_targets))
 
 
-  let clean ~ctxt pkg args  =
-    run_clean ~ctxt args;
+  let clean ~ctxt pkg extra_args  =
+    run_clean ~ctxt extra_args;
     List.iter
       (function
          | Library (cs, _, _) ->
@@ -6827,7 +7248,7 @@
 
   type run_t =
     {
-      args: args;
+      extra_args: string list;
       run_path: unix_filename;
     }
 
@@ -6849,8 +7270,7 @@
           cs.cs_name^".docdir";
         ]
     in
-    run_ocamlbuild ~ctxt
-      {run.args with extra = index_html :: run.args.extra} argv;
+    run_ocamlbuild ~ctxt (index_html :: run.extra_args) argv;
     List.iter
       (fun glb ->
          match OASISFileUtil.glob ~ctxt (Filename.concat tgt_dir glb) with
@@ -6868,7 +7288,7 @@
 end
 
 
-# 6851 "setup.ml"
+# 7271 "setup.ml"
 module CustomPlugin = struct
 # 22 "src/plugins/custom/CustomPlugin.ml"
 
@@ -7000,15 +7420,13 @@
 end
 
 
-# 6983 "setup.ml"
+# 7403 "setup.ml"
 open OASISTypes;;
 
 let setup_t =
   {
      BaseSetup.configure = InternalConfigurePlugin.configure;
-     build =
-       OCamlbuildPlugin.build
-         {OCamlbuildCommon.plugin_tags = None; extra = ["-use-ocamlfind"]};
+     build = OCamlbuildPlugin.build ["-use-ocamlfind"];
      test =
        [
           ("devel",
@@ -7126,11 +7544,7 @@
           ("api-oasis",
             OCamlbuildDocPlugin.doc_build
               {
-                 OCamlbuildDocPlugin.args =
-                   {
-                      OCamlbuildCommon.plugin_tags = None;
-                      extra = ["-use-ocamlfind"]
-                   };
+                 OCamlbuildDocPlugin.extra_args = ["-use-ocamlfind"];
                  run_path = "src/"
               })
        ];
@@ -7254,11 +7668,7 @@
           ("api-oasis",
             OCamlbuildDocPlugin.doc_clean
               {
-                 OCamlbuildDocPlugin.args =
-                   {
-                      OCamlbuildCommon.plugin_tags = None;
-                      extra = ["-use-ocamlfind"]
-                   };
+                 OCamlbuildDocPlugin.extra_args = ["-use-ocamlfind"];
                  run_path = "src/"
               })
        ];
@@ -11805,9 +12215,9 @@
           schema_data = PropList.Data.create ();
           plugin_data = []
        };
-     oasis_fn = None;
-     oasis_version = "0.4.11~HEAD";
-     oasis_digest = None;
+     oasis_fn = Some "_oasis";
+     oasis_version = "0.4.10";
+     oasis_digest = Some "M\233\243N\025\208\179b\202K\232\t\132~\222\226";
      oasis_exec = None;
      oasis_setup_args = [];
      setup_update = false
@@ -11815,7 +12225,7 @@
 
 let setup () = BaseSetup.setup setup_t;;
 
-# 11799 "setup.ml"
+# 12209 "setup.ml"
 let setup_t = BaseCompat.Compat_0_4.adapt_setup_t setup_t
 open BaseCompat.Compat_0_4
 (* OASIS_STOP *)
--- ./src/base/BaseBuilt.ml
+++ ./src/base/BaseBuilt.ml
@@ -165,6 +165,7 @@
       ~source_file_exists:(fun fn ->
         OASISFileUtil.file_exists_case (OASISHostPath.of_unix fn))
       ~is_native:(bool_of_string (is_native ()))
+      ~ext_obj:(ext_obj())
       (cs, bs, obj)
   in
   let evs =
--- ./src/base/BaseCheck.ml
+++ ./src/base/BaseCheck.ml
@@ -118,9 +118,11 @@
   in
   let findlib_dir pkg =
     let dir =
+      OASISHostPath.of_unix (
+        OASISHostPath.ocamlfind_unquote (
       OASISExec.run_read_one_line ~ctxt:!BaseContext.default
         (ocamlfind ())
-        ["query"; "-format"; "%d"; pkg]
+            ["query"; "-format"; "%d"; pkg] ) )
     in
     if Sys.file_exists dir && Sys.is_directory dir then
       dir
--- ./src/base/BaseCustom.ml
+++ ./src/base/BaseCustom.ml
@@ -31,7 +31,7 @@
   OASISExec.run ~ctxt:!BaseContext.default ~quote:false
     (var_expand cmd)
     (List.map
-       var_expand
+       (var_expand ~quoted:true)
        (args @ (Array.to_list extra_args)))
 
 
--- ./src/base/BaseEnv.ml
+++ ./src/base/BaseEnv.ml
@@ -69,7 +69,7 @@
 let var_lxr = Genlex.make_lexer []
 
 
-let rec var_expand str =
+let rec var_expand ?(quoted=false) str =
   let buff =
     Buffer.create ((String.length str) * 2)
   in
@@ -97,7 +97,11 @@
            | [Genlex.Ident "ocaml_escaped"; Genlex.String s] ->
              String.escaped s
            | [Genlex.Ident nm] ->
-             var_get nm
+               let s = var_get nm in
+               if quoted then
+                 OASISHostPath.quote s
+               else
+                 s
            | _ ->
              failwithf
                (f_ "Unknown expression '%s' in variable expansion of %s.")
--- ./src/base/BaseEnv.mli
+++ ./src/base/BaseEnv.mli
@@ -73,8 +73,9 @@
 
 (** Expand variable that can be found in string. Variable follow definition of
     variable for [Buffer.add_substitute].
+    quoted is false by default
 *)
-val var_expand: string -> string
+val var_expand: ?quoted:bool -> string -> string
 
 
 (** Get variable. *)
--- ./src/base/BaseOCamlcConfig.ml
+++ ./src/base/BaseOCamlcConfig.ml
@@ -116,6 +116,9 @@
     match nm with
       | "ocaml_version" ->
         "version", chop_version_suffix
+      | "standard_library"
+      | "standard_library_default" ->
+          nm, ( fun x -> OASISHostPath.of_unix x)
       | _ -> nm, (fun x -> x)
   in
   var_redefine
--- ./src/base/BaseSetup.ml
+++ ./src/base/BaseSetup.ml
@@ -93,9 +93,27 @@
 
 let configure ~ctxt t args =
   (* Run configure *)
+
+  (* use-bash is an exception. It's already needed to run the
+     pre-configure script. *)
+  let rec f = function
+    | [] ->
+      begin
+        try
+          let x = Sys.getenv "USE_BASH" in
+            OASISHostPath.bash_cmd := (fun () -> x);
+        with
+          _ -> ()
+      end
+    | "--use-bash"::x::_ ->
+        OASISHostPath.bash_cmd := (fun () -> x);
+    | _::tl -> f tl
+  in
+    f (Array.to_list args);
   BaseCustom.hook
     t.package.conf_custom
     (fun () ->
+         OASISHostPath.bash_cmd := BaseStandardVar.bash_cmd;
        (* Reload if preconf has changed it *)
        begin
          try
--- ./src/base/BaseStandardVar.ml
+++ ./src/base/BaseStandardVar.ml
@@ -135,15 +135,43 @@
 
 
 let (/) a b =
-  if os_type () = Sys.os_type then
+  let os = os_type () in
+  if os = Sys.os_type then
+    if Sys.os_type = "Win32" && OASISHostPath.use_bash () then
+      OASISUnixPath.concat a b
+    else
     Filename.concat a b
-  else if os_type () = "Unix" || os_type () = "Cygwin" then
+  else if os = "Unix" || os = "Cygwin" then
     OASISUnixPath.concat a b
   else
-    OASISUtils.failwithf (f_ "Cannot handle os_type %s filename concat")
-      (os_type ())
+    OASISUtils.failwithf (f_ "Cannot handle os_type %s filename concat") os
 (**/**)
 
+let auto_bash =
+  lazy (
+    try
+      let bash = OASISFileUtil.which ~plain:true "bash" in
+      let sh = Filename.concat (Filename.dirname bash) "sh.exe" in
+      if Sys.file_exists sh then
+        sh
+      else
+        bash
+    with
+    | Not_found | Sys_error _ -> "" )
+
+let auto_bash () =
+  if Sys.os_type <> "Win32" then
+    ""
+  else
+    Lazy.force auto_bash
+
+let bash_cmd =
+  var_define
+   ~short_desc:(fun () -> s_ "Enforced bash shell:")
+    ~cli:CLIAuto
+    ~arg_help:"program"
+    "use_bash"
+    auto_bash
 
 let prefix =
   p "prefix"
@@ -151,10 +179,30 @@
     (fun () ->
        match os_type () with
          | "Win32" ->
+          let getenv w =
+            try
+              Some(Sys.getenv w)
+            with
+            | Not_found -> None
+          in
+          let s =
+            if Sys.word_size = 64 then
+              getenv "ProgramW6432"
+            else
+              None
+          in
+          let s =
+            if s = None then
+              getenv "PROGRAMFILES"
+            else
+              s
+          in
            let program_files =
-             Sys.getenv "PROGRAMFILES"
+            match s with
+            | None -> "C:\\Program Files"
+            | Some x -> x
            in
-           program_files/(pkg_name ())
+          OASISHostPath.of_unix (program_files/(pkg_name ()))
          | _ ->
            "/usr/local")
 
@@ -240,7 +288,15 @@
 let docdir =
   p "docdir"
     (fun () -> s_ "Documentation root")
-    (fun () -> "$datarootdir"/"doc"/"$pkg_name")
+    (fun () ->
+      (* TODO: (Windows only?) "$pkg_name" is not always substituted
+       * (at least if datarootdir contains spaces or other garbage)
+       * I haven't looked up why.
+       *)
+      match os_type () with
+        | "Win32" -> "$datarootdir"/"doc"/ ( pkg_name () )
+        | _ -> "$datarootdir"/"doc"/"$pkg_name"
+    )
 
 
 let htmldir =
@@ -314,9 +370,10 @@
     ~short_desc:(fun () -> s_ "Remove a file.")
     "rm"
     (fun () ->
-       match os_type () with
-         | "Win32" -> "del"
-         | _ -> "rm -f")
+       if not (OASISHostPath.use_bash ()) && os_type () = "Win32" then
+         "del"
+       else
+         "rm -f" )
 
 
 let rmdir =
@@ -324,9 +381,10 @@
     ~short_desc:(fun () -> s_ "Remove a directory.")
     "rmdir"
     (fun () ->
-       match os_type () with
-         | "Win32" -> "rd"
-         | _ -> "rm -rf")
+       if not (OASISHostPath.use_bash ()) && os_type () = "Win32" then
+         "rd"
+       else
+         "rm -rf")
 
 
 let debug =
@@ -390,14 +448,26 @@
          let has_native_dynlink =
            let ocamlfind = ocamlfind () in
            try
-             let fn =
+             (* -format %d/%a doesn't work, because ocamlfind quotes %d
+                * and %a separatly *)
+             let fn1 =
+               OASISHostPath.ocamlfind_unquote (
+                 OASISExec.run_read_one_line
+                   ~ctxt:!BaseContext.default
+                   ocamlfind
+                   ["query"; "-predicates"; "native"; "dynlink";
+                    "-format"; "%d"] )
+             in
+             let fn2 =
+               OASISHostPath.ocamlfind_unquote (
                OASISExec.run_read_one_line
                  ~ctxt:!BaseContext.default
                  ocamlfind
                  ["query"; "-predicates"; "native"; "dynlink";
-                  "-format"; "%d/%a"]
+                    "-format"; "%a"]
+               )
              in
-             Sys.file_exists fn
+             fn1 <> "" && fn2 <> "" && Sys.file_exists (Filename.concat fn1 fn2)
            with _ ->
              false
          in
@@ -424,3 +494,5 @@
   rpkg := Some pkg;
   List.iter (fun f -> f pkg.oasis_version) !var_cond
 
+let () =
+  OASISHostPath.bash_cmd := bash_cmd
--- ./src/base/BaseStandardVar.mli
+++ ./src/base/BaseStandardVar.mli
@@ -73,6 +73,9 @@
 val systhread_supported:      unit -> string
 
 
+
+val bash_cmd:                 unit -> string
+
 (** {2 Paths}
 
     See {{:http://www.gnu.org/prep/standards/html_node/Directory-Variables.html} GNU standards}.
--- ./src/dynrun/OASISDynRun.ml
+++ ./src/dynrun/OASISDynRun.ml
@@ -56,7 +56,12 @@
 
   let setup ~ctxt setup_t =
     let tmp_setup_fn =
-      Filename.temp_file (setup_t.package.name^"-setup") ".ml" in
+      if Sys.os_type <> "Win32" then
+        Filename.temp_file (setup_t.package.name^"-setup") ".ml"
+      else
+        (* dirty hack, because otherwise to_unix will fail *)
+        Filename.temp_file ~temp_dir:"." ("tmp-"^setup_t.package.name^"-setup") ".ml"
+    in
     let restored = ref false in
     let cleanup ~ctxt () =
       if not !restored then begin
--- ./src/oasis/OASISCustom.ml
+++ ./src/oasis/OASISCustom.ml
@@ -38,14 +38,14 @@
   let pre_command =
     new_field_conditional schm ("Pre"^nm^"Command")
       ~default:None
-      (opt command_line)
+      (opt command_line_warn)
       hlp_pre
       (fun pkg -> (sync pkg).pre_command)
   in
   let post_command =
     new_field_conditional schm ("Post"^nm^"Command")
       ~default:None
-      (opt command_line)
+      (opt command_line_warn)
       hlp_post
       (fun pkg -> (sync pkg).post_command)
   in
--- ./src/oasis/OASISExec.ml
+++ ./src/oasis/OASISExec.ml
@@ -25,26 +25,170 @@
 open OASISUtils
 open OASISMessage
 
+let is_dubious_char = function
+  | '+' | '~' | ':' | '.' | '-' | '_' | '/' | '\\' -> false
+  | c ->
+    OASISString.is_digit c = false &&
+    OASISString.is_alpha c = false
 
-(* TODO: I don't like this quote, it is there because $(rm) foo expands to
- * 'rm -f' foo...
-*)
-let run ~ctxt ?f_exit_code ?(quote=true) cmd args =
+
+let win_quote_needed str =
+  let f = function
+    | 'a' .. 'z'  | 'A' .. 'Z' | '0' .. '9'
+    | '_' | '-' | '~' | '.' | ':' | ',' | '\\' -> false
+    | _ -> true
+  in
+    str = "" || OASISString.exists f str
+
+let is_simple_command str =
+  String.length str > 0 &&
+  not (OASISString.exists is_dubious_char str)
+
+let is_path_sep = function
+  | '/' | '\\' -> true
+  | _ -> false
+
+let starts_with_absolute_path cmd =
+  let len = String.length cmd in
+    if len < 3 then
+      false
+    else
+      let c0 = cmd.[0] in
+      let c1 = cmd.[1] in
+        if is_path_sep c0 && is_path_sep c1 then (* network devices: "//" *)
+          true
+        else if len = 3 then
+          false
+        else  (* C:\.... *)
+          OASISString.is_alpha c0 && c1 = ':' && is_path_sep cmd.[2]
+
+let exe_exts = lazy
+  begin
+    let exts =
+      try
+        OASISString.nsplit
+          (Sys.getenv "PATHEXT")
+          ';'
+      with
+        | Not_found -> []
+    in
+    let exts' =
+      List.filter
+        ( fun a -> a <> "" && a.[0] = '.' && a <> ".exe" )
+        (List.map OASISString.lowercase_ascii exts)
+    in
+      ".exe"::exts'
+  end
+
+let exe_file_exists fln =
+  Sys.file_exists fln ||
+  List.exists
+    (fun a -> Sys.file_exists ( fln ^ a ) )
+    (Lazy.force exe_exts)
+
+
+let quote_anyway cmd =
+  if Sys.os_type <> "Win32" then
+    false
+  else if is_simple_command cmd then
+    true
+  else
+    OASISString.exists OASISString.is_whitespace cmd &&
+      starts_with_absolute_path cmd &&
+      exe_file_exists cmd
+
+
+let run_bash ~ctxt ?f_exit_code ?(quote=true) cmd args =
+  let fn = Filename.temp_file "oasis-" ".sh" in
+  let fn_deleted = ref false in
+    try
+      begin
+        let ch = open_out_bin fn in
+        let ch_closed = ref false in
+          try
+            begin
   let cmd =
-    if quote then
-      if Sys.os_type = "Win32" then
-        if String.contains cmd ' ' then
-          (* Double the 1st double quote... win32... sigh *)
-          "\""^(Filename.quote cmd)
+                if quote || quote_anyway cmd then
+                  OASISHostPath.quote (OASISHostPath.of_unix cmd)
+                else
+                  cmd
+              in
+                output_string ch cmd;
+                List.iter
+                  ( fun s -> output_char ch ' '; output_string ch s )
+                  args ;
+                output_char ch '\n';
+                ch_closed:=true ;
+                close_out ch;
+                let bash = !OASISHostPath.bash_cmd () in
+                let add_quotes = ref false in
+                let shell_cmd =
+                  if Sys.os_type <> "Win32" then
+                    Filename.quote bash
+                  else
+                    if win_quote_needed bash = false then
+                      bash
+                    else
+                      begin
+                        add_quotes := true;
+                        Filename.quote bash
+                      end
+                in
+                let cmdline_orig = String.concat " " (cmd :: args) in
+                let cmdline =
+                  let s = shell_cmd ^ " " ^ (Filename.quote fn) in
+                    if !add_quotes then
+                      "\"" ^ s ^ "\""
         else
+                      s
+                in
+                  info ~ctxt (f_ "Running command '%s'") cmdline_orig;
+                  let ret = Sys.command cmdline in
+                    fn_deleted := true;
+                    Sys.remove fn;
+                    match f_exit_code, ret with
+                      | None, 0 -> ()
+                      | None, i ->
+                          failwithf
+                            (f_ "Command '%s' terminated with error code %d")
+                            cmdline_orig i
+                      | Some f, i ->
+                          f i
+            end
+          with
+            | x when !ch_closed = false ->
+                close_out_noerr ch;
+                raise x
+      end
+    with
+      | x when !fn_deleted = false ->
+          (try Sys.remove fn with _ -> () ) ;
+          raise x
+
+let run_default ~ctxt ?f_exit_code ?(quote=true) cmd args =
+  let add_quotes = ref false in
+  let cmd =
+    if quote || quote_anyway cmd then
+      if Sys.os_type = "Win32" then
+        begin
+          if win_quote_needed cmd = false then
           cmd
       else
+            begin
+              add_quotes := true;
+              Filename.quote cmd
+            end
+        end
+      else
         Filename.quote cmd
     else
       cmd
   in
   let cmdline =
-    String.concat " " (cmd :: args)
+    let s = String.concat " " (cmd :: args) in
+      match !add_quotes with
+        | true -> "\"" ^ s ^ "\""
+        | false -> s
   in
   info ~ctxt (f_ "Running command '%s'") cmdline;
   match f_exit_code, Sys.command cmdline with
@@ -56,6 +200,13 @@
     | Some f, i ->
       f i
 
+let run ~ctxt ?f_exit_code ?quote cmd args =
+  if OASISHostPath.use_bash () &&
+     (Sys.os_type <> "Win32" || not (Filename.check_suffix cmd ".bat"))
+  then
+    run_bash ~ctxt ?f_exit_code ?quote cmd args
+  else
+    run_default ~ctxt ?f_exit_code ?quote cmd args
 
 let run_read_output ~ctxt ?f_exit_code cmd args =
   let fn =
--- ./src/oasis/OASISFileTemplate.ml
+++ ./src/oasis/OASISFileTemplate.ml
@@ -496,6 +496,12 @@
       if Sys.file_exists bak then begin
         info ~ctxt (f_ "Restore file '%s' with backup file '%s'.")
           fn bak;
+        if Sys.os_type = "Win32" then (
+          try
+            Sys.remove fn
+          with
+          | Sys_error _ -> ()
+        );
         Sys.rename bak fn
       end else begin
         warning ~ctxt
--- ./src/oasis/OASISFileUtil.ml
+++ ./src/oasis/OASISFileUtil.ml
@@ -84,7 +84,7 @@
   ) alternatives
 
 
-let which ~ctxt prg =
+let which ?(plain=false) ?ctxt prg =
   let path_sep =
     match Sys.os_type with
       | "Win32" ->
@@ -96,11 +96,19 @@
   let exec_ext =
     match Sys.os_type with
       | "Win32" ->
-        "" :: (OASISString.nsplit (Sys.getenv "PATHEXT") path_sep)
+        "" :: (List.map
+                 OASISString.lowercase_ascii
+                 (OASISString.nsplit (Sys.getenv "PATHEXT") path_sep))
       | _ ->
         [""]
   in
+  let p =
   find_file ~case_sensitive:false [path_lst; [prg]] exec_ext
+  in
+  if plain then
+    p
+  else
+    OASISHostPath.of_unix p
 
 
 (**/**)
@@ -117,35 +125,54 @@
     dn
 
 
-let q = Filename.quote
+let q s = OASISHostPath.quote (OASISHostPath.of_unix s)
 (**/**)
 
-
 let cp ~ctxt ?(recurse=false) src tgt =
   if recurse then
-    match Sys.os_type with
-      | "Win32" ->
-        OASISExec.run ~ctxt
-          "xcopy" [q src; q tgt; "/E"]
-      | _ ->
-        OASISExec.run ~ctxt
-          "cp" ["-r"; q src; q tgt]
+    (*
+      'xcopy /E' and 'cp -r' don't have the same semantic!
+      -dir2 does exist:
+        xcopy dir dir2 /E -> copys content of dir into dir2 (dir2/dir doesn't exist!)
+        cp -r dir dir2    -> copys dir to dir2 (dir2/dir does exist!)
+      -dir2 doesn't exist:
+        xcopy dir dir2 /E -> request on command line, if dir2 is an directory or file.
+        cp -r dir dir2    -> dir and dir2 have the same content (dir2/dir doesn't exist)
+      Probably, there are even more differences,....
+    *)
+    if Sys.os_type = "Win32" && OASISHostPath.use_bash () = false then
+      let tgt_real =
+        if Sys.file_exists tgt = false then
+          begin
+            OASISExec.run ~ctxt "md" [q tgt];
+            tgt
+          end
   else
-    OASISExec.run ~ctxt
-      (match Sys.os_type with
-        | "Win32" -> "copy"
-        | _ -> "cp")
-      [q src; q tgt]
-
+          let base = Filename.basename src in
+          if base = "." then
+            tgt
+          else
+            let tgt_real = Filename.concat tgt base in
+            if Sys.file_exists tgt_real = false then
+              OASISExec.run ~ctxt "md" [q tgt_real];
+            tgt_real
+      in
+      OASISExec.run ~ctxt "xcopy" [q src; q tgt_real; "/E" ; "/Q" ; "/Y"]
+    else
+      OASISExec.run ~ctxt "cp" ["-r"; q src; q tgt]
+  else if Sys.os_type = "Win32" && OASISHostPath.use_bash () = false then
+    OASISExec.run ~ctxt "copy" [q src; q tgt ; "/Y"]
+  else
+    OASISExec.run ~ctxt "cp" [q src; q tgt]
 
 let mkdir ~ctxt tgt =
   OASISExec.run ~ctxt
-    (match Sys.os_type with
-      | "Win32" -> "md"
-      | _ -> "mkdir")
+    ( if Sys.os_type = "Win32" && not (OASISHostPath.use_bash ()) then
+        "md"
+      else
+        "mkdir" )
     [q tgt]
 
-
 let rec mkdir_parent ~ctxt f tgt =
   let tgt =
     fix_dir tgt
@@ -171,10 +198,9 @@
 
 let rmdir ~ctxt tgt =
   if Sys.readdir tgt = [||] then begin
-    match Sys.os_type with
-      | "Win32" ->
+    if Sys.os_type = "Win32" && OASISHostPath.use_bash () = false then
         OASISExec.run ~ctxt "rd" [q tgt]
-      | _ ->
+    else
         OASISExec.run ~ctxt "rm" ["-r"; q tgt]
   end else begin
     OASISMessage.error ~ctxt
--- ./src/oasis/OASISFileUtil.mli
+++ ./src/oasis/OASISFileUtil.mli
@@ -44,8 +44,7 @@
 
 (** Find real filename of an executable.
 *)
-val which: ctxt:OASISContext.t -> host_filename -> host_filename
-
+val which: ?plain:bool -> ?ctxt:OASISContext.t -> host_filename -> host_filename
 
 (** Copy a file.
 *)
--- ./src/oasis/OASISHostPath.ml
+++ ./src/oasis/OASISHostPath.ml
@@ -27,6 +27,118 @@
 
 module Unix = OASISUnixPath
 
+let bash_cmd = ref ( fun () -> "" )
+
+let use_bash () = ( !bash_cmd () ) <> ""
+
+
+(* generic quote and unixquote are taken from ocaml source *)
+let generic_quote quotequote s =
+  let l = String.length s in
+  let b = Buffer.create (l + 20) in
+    Buffer.add_char b '\'';
+    for i = 0 to l - 1 do
+      if s.[i] = '\'' then
+        Buffer.add_string b quotequote
+      else
+        Buffer.add_char b  s.[i]
+    done;
+    Buffer.add_char b '\'';
+    Buffer.contents b
+
+let unixquote = generic_quote "'\\''"
+
+let win = Sys.os_type = "Win32"
+
+let quote str =
+  if win && use_bash () then
+    unixquote str
+  else
+    quote str
+
+(* uniform_path (only called, if Sys.os_type = "Win32")
+ * - enforces uniform path seperators
+ * - strips trailing slashes (exceptions in case of C:\ and / )
+ * - removes (some) unnecessary file components like ./././
+ *)
+
+let get_naccu accu str first pos =
+  (* I assume c//d is identic to c/d
+   * the only exception (Network devices \\xyz\asdf)
+   * is covered in uniform_path
+   *)
+  if first = pos then
+    accu
+  else
+    let nlen = pos - first in
+    let nstr = String.sub str first nlen in
+      (* test/././ is the same as test *)
+      if nlen = 1 && nstr = "." then
+        accu
+      (* a/b/../ is the same as a *)
+      else if nlen = 2 && nstr = ".." then
+        match accu with
+          | []      -> [ nstr ]
+          | ".."::_ -> nstr::accu
+          | hd::tl  -> tl
+      else
+        nstr::accu
+
+let is_path_sep = function
+  | '\\' | '/' -> true
+  | _ -> false
+
+
+let uniform_path path_sep = function
+  | "" -> "" (* Raise an exception? Or an possible intermediate result?
+             * Filename.basename and dirname also don't raise exceptions *)
+  | str ->
+      let rec iter accu str len first pos =
+        if pos >= len then
+          List.rev (get_naccu accu str first pos)
+        else
+          let next = succ pos in
+            match is_path_sep str.[pos] with
+              | true -> iter (get_naccu accu str first pos) str len next next
+              | false -> iter accu str len first next
+      in
+        let is_unix_root = is_path_sep str.[0] in
+        let len = String.length str in
+        let next_sep = len > 1 && is_path_sep str.[1] in
+        let is_network_root = is_unix_root && next_sep in
+        let is_currel = str.[0] = '.' && ( next_sep || len = 1 ) in
+        let l = iter [] str len 0 0 in
+        (* Trailing slashes are normally stripped.
+         * This is not possible in case of root folders
+         * Sys.file_exists "C:" is false, Sys.file_exists "C:\\" true
+         *)
+        let l_min =
+          match l with
+            | [] -> [ "" ]
+            | _ -> l
+        in
+        let l =
+          if is_network_root then
+            ""::""::l_min
+          else if is_unix_root then
+            ""::l_min
+          else if is_currel then
+            "."::l
+          else
+            match l with
+              | s :: [] ->
+                  (* root folders like C:\ *)
+                  if String.length s = 2 && s.[1] = ':' &&
+                    len > 2 && is_path_sep str.[2]
+                  then
+                    s :: [ "" ]
+                  else
+                    l
+              | _ -> l
+        in
+          String.concat path_sep l
+
+
 
 let make =
   function
@@ -40,22 +152,31 @@
   match Sys.os_type with
   | "Unix" | "Cygwin" -> ufn
   | "Win32" ->
-    make
-      (List.map
-         (fun p ->
-            if p = Unix.current_dir_name then
-              current_dir_name
-            else if p = Unix.parent_dir_name then
-              parent_dir_name
+    let path_sep =
+      if use_bash () then
+        "/"
             else
-              p)
-         (OASISString.nsplit ufn '/'))
+        "\\"
+    in
+    uniform_path path_sep ufn
   | os_type ->
     OASISUtils.failwithf
       (f_ "Don't know the path format of os_type %S when translating unix \
            filename. %S")
       os_type ufn
 
+(* see findlib's src/findlib/frontend.ml for details *)
+let ocamlfind_unquote dir =
+  match Sys.os_type with
+  | "Cygwin"
+  | "Win32" ->
+    let len = String.length dir in
+    if len < 3 || dir.[0] <> '"' || dir.[len - 1] <> '"' ||
+       String.contains dir ' ' = false then
+      dir
+    else
+      String.sub dir 1 (len - 2)
+  | _ -> dir
 
 (* END EXPORT *)
 
--- ./src/oasis/OASISHostPath.mli
+++ ./src/oasis/OASISHostPath.mli
@@ -29,6 +29,27 @@
 open OASISTypes
 
 
+(**
+    The function should return an unix like shell,
+    that will be used to execute external commands.
+
+    The default function returns an empty string.
+    (system default will be used)
+*)
+val bash_cmd : (unit -> host_filename) ref
+
+(** True, if bash_cmd_program will return a non-empty
+    host_filename *)
+val use_bash: unit -> bool
+
+
+(**
+   On windows, the Unix quote function
+   will be used, if use_base () is true.
+   Otherwise identic to Filename.quote
+*)
+val quote: string -> string
+
 (** Create a filename out of its components.
 *)
 val make: host_filename list -> host_filename
@@ -57,5 +78,9 @@
 val add_extension: host_filename -> string -> host_filename
 
 
+(** Unquote functions for filenames from 'ocamlfind query ...' *)
+val ocamlfind_unquote: string -> string
+
+
 (** Map for host filename. {b Not exported.} *)
 module Map: OASISUtils.MapExt.S with type key = host_filename
--- ./src/oasis/OASISObject.ml
+++ ./src/oasis/OASISObject.ml
@@ -54,6 +54,7 @@
     ~ctxt
     ~is_native
     ~source_file_exists
+    ~ext_obj
     (cs, bs, obj) =
 
   let find_module ext modul =
@@ -67,12 +68,12 @@
       | [ m ] -> (find_module ".cmi" m,
           find_module ".cmo" m,
           find_module ".cmx" m,
-          find_module ".o" m,
+          find_module ext_obj m,
           fun x -> x)
       | _ -> ([cs.cs_name ^ ".cmi"],
           [cs.cs_name ^ ".cmo"],
           [cs.cs_name ^ ".cmx"],
-          [cs.cs_name ^ ".o"],
+          [cs.cs_name ^ ext_obj],
           OASISUnixPath.concat bs.bs_path)
   in
   List.map (List.map f) (
--- ./src/oasis/OASISObject.mli
+++ ./src/oasis/OASISObject.mli
@@ -49,6 +49,7 @@
   ctxt:OASISContext.t ->
   is_native:bool ->
   source_file_exists:(unix_filename -> bool) ->
+  ext_obj:string ->
   common_section * build_section * object_ ->
   unix_filename list list
 
--- ./src/oasis/OASISString.ml
+++ ./src/oasis/OASISString.ml
@@ -169,18 +169,34 @@
   else
     s
 
-(* END EXPORT *)
+let exists f str =
+  let rec iter i =
+    if i < 0 then
+      false
+    else if f str.[i] then
+      true
+    else
+      iter (pred i)
+  in
+    iter (String.length str - 1)
 
-(*  TODO: replace lowercase_ascii, capitalize_ascii and uncapitalize_ascii
-    functions by String.*_ascii function when OCaml minimal version will be
-    4.03.0.
- *)
+let is_digit c =
+  '0' <= c && c <= '9'
+
+let is_alpha c =
+  ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')
 
 let is_whitespace =
   function
     | ' ' | '\r' | '\n' | '\t' -> true
     |  _  -> false
 
+(* END EXPORT *)
+
+(*  TODO: replace lowercase_ascii, capitalize_ascii and uncapitalize_ascii
+    functions by String.*_ascii function when OCaml minimal version will be
+    4.03.0.
+ *)
 
 let tokenize ?(is_whitespace=is_whitespace) ?(tokens=[]) str =
   let lst = ref [] in
--- ./src/oasis/OASISValues.ml
+++ ./src/oasis/OASISValues.ml
@@ -494,6 +494,38 @@
            space_separated.print (cmd :: args))
     }
 
+let command_line_warn =
+  let c = command_line in
+  let is_unix_centric_operator = function
+    | "&&" | ";" | "||" -> true
+    | _ -> false
+  in
+
+  let parse = ( fun ~ctxt s ->
+                let (cmd,args) as cmd_args = c.parse ~ctxt s in
+                  if String.length cmd > 0 && cmd.[0] <> '$' then
+                    begin
+                      OASISMessage.warning
+                        ~ctxt
+                        "External commands may differ from platform to platform (%s)"
+                        cmd
+                    end;
+                  if List.exists is_unix_centric_operator args then
+                    begin
+                      OASISMessage.warning
+                        ~ctxt
+                        "Command line '%s' seems to be *nix specific"
+                        (String.concat "" (cmd::args))
+                    end;
+                  cmd_args )
+  in
+    {
+      parse ;
+      update = c.update;
+      print = c.print;
+    }
+
+
 
 let command_line_options =
   { parse = (fun ~ctxt:_ s -> POSIXShell.split s);
--- ./src/oasis/OASISValues.mli
+++ ./src/oasis/OASISValues.mli
@@ -183,6 +183,9 @@
 val command_line: (string * string list) t
 
 
+(** As above, but emmit warnings by dubious constructs *)
+val command_line_warn : (string * string list) t
+
 (** Arguments of command line programs.  See {!OASISUtils.POSIX.split}
     for more information. *)
 val command_line_options: string list t
--- ./src/oasis/OASISVersion.ml
+++ ./src/oasis/OASISVersion.ml
@@ -38,8 +38,8 @@
 
 
 (* Range of allowed characters *)
-let is_digit c = '0' <= c && c <= '9'
-let is_alpha c = ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')
+let is_digit = OASISString.is_digit
+let is_alpha = OASISString.is_alpha
 let is_special = function | '.' | '+' | '-' | '~' -> true | _ -> false
 
 
--- ./src/plugins/custom/CustomPlugin.ml
+++ ./src/plugins/custom/CustomPlugin.ml
@@ -200,7 +200,7 @@
       schema
       id
       nm
-      command_line
+      command_line_warn
       (* TODO: remove when fun () -> s_ be replaced *)
       (fun () -> s_ hlp)
       data (fun _ t -> t.cmd_main)
@@ -211,7 +211,7 @@
       id
       (nm^"Clean")
       ~default:None
-      (opt command_line)
+      (opt command_line_warn)
       (* TODO: remove when fun () -> s_ be replaced *)
       (fun () -> s_ hlp_clean)
       data (fun _ t -> t.cmd_clean)
@@ -222,7 +222,7 @@
       id
       (nm^"Distclean")
       ~default:None
-      (opt command_line)
+      (opt command_line_warn)
       (* TODO: remove when fun () -> s_ be replaced *)
       (fun () -> s_ hlp_distclean)
       data (fun _ t -> t.cmd_distclean)
@@ -426,7 +426,7 @@
       id
       "Clean"
       ~default:None
-      (opt command_line)
+      (opt command_line_warn)
       (fun () ->
          s_ "Run command to clean test step.")
       test_data (fun _ t -> t.cmd_clean)
@@ -437,7 +437,7 @@
       id
       "Distclean"
       ~default:None
-      (opt command_line)
+      (opt command_line_warn)
       (fun () ->
          s_ "Run command to distclean test step.")
       test_data (fun _ t -> t.cmd_distclean)
--- ./src/plugins/extra/devfiles/DevFilesPlugin.ml
+++ ./src/plugins/extra/devfiles/DevFilesPlugin.ml
@@ -201,7 +201,7 @@
           Printf.bprintf buff
             "setup.exe: setup.ml%s\n\
              \tocamlfind ocamlopt -o $@%s setup.ml || ocamlfind ocamlc -o $@%s setup.ml || true\n\
-             \t$(RM) setup.cmi setup.cmo setup.cmx setup.o setup.cmt\n\n"
+             \t$(RM) setup.cmi setup.cmo setup.cmx setup.o setup.obj setup.cmt\n\n"
             makefile_setup_deps packages packages;
         end;
         Buffer.add_string buff (".PHONY: "^(String.concat " " targets)^"\n");
@@ -226,7 +226,7 @@
             Printf.sprintf
               "if [ ! -e setup.exe ] || [ _oasis -nt setup.exe ] || [ setup.ml -nt setup.exe ] || [ configure -nt setup.exe ]; then\n  \
                ocamlfind ocamlopt -o setup.exe%s setup.ml || ocamlfind ocamlc -o setup.exe%s setup.ml || exit 1\n  \
-               rm -f setup.cmi setup.cmo setup.cmx setup.o setup.cmt\n\
+               rm -f setup.cmi setup.cmo setup.cmx setup.o setup.obj setup.cmt\n\
                fi\n\
                ./setup.exe -configure \"$@\""
               packages packages
--- ./src/plugins/internal/InternalInstallPlugin.ml
+++ ./src/plugins/internal/InternalInstallPlugin.ml
@@ -47,12 +47,21 @@
 let install_findlib_ev = "install-findlib"
 
 
-(* TODO: this can be more generic and used elsewhere. *)
-let win32_max_command_line_length = 8000
-
-
 let split_install_command ocamlfind findlib_name meta files =
-  if Sys.os_type = "Win32" then
+  if Sys.os_type <> "Win32" then
+    ["install" :: findlib_name :: meta :: files]
+  else
+    let f s =
+      OASISHostPath.quote ( OASISHostPath.of_unix s )
+    in
+    let files = List.map f files in
+    let meta = f meta  in
+    let win32_max_command_line_length =
+      if OASISHostPath.use_bash () = false then
+        7900
+      else
+        30000
+    in
     (* Arguments for the first command: *)
     let first_args = ["install"; findlib_name; meta] in
     (* Arguments for remaining commands: *)
@@ -110,10 +119,11 @@
                   let cmds = split other_args others in
                   cmd :: cmds
     in
+    if files = [] then
+      [ first_args ]
+    else
     (* The first command does not use -add: *)
     split first_args files
-  else
-    ["install" :: findlib_name :: meta :: files]
 
 
 let install =
@@ -534,7 +544,10 @@
     if ev = install_file_ev then begin
       if OASISFileUtil.file_exists_case data then begin
         info (f_ "Removing file '%s'") data;
-        Sys.remove data
+        (try Sys.remove data
+        with Sys_error _ when
+            Sys.os_type = "Win32" &&
+            Filename.basename data = "setup.ml" -> ());
       end else begin
         warning (f_ "File '%s' doesn't exist anymore") data
       end
--- ./src/plugins/ocamlbuild/MyOCamlbuildFindlib.ml
+++ ./src/plugins/ocamlbuild/MyOCamlbuildFindlib.ml
@@ -93,7 +93,9 @@
   with Not_found -> s
 
 (* ocamlfind command *)
-let ocamlfind x = S[Sh (exec_from_conf "ocamlfind"); x]
+let ocamlfind x = S[Sh (
+  Ocamlbuild_pack.Shell.quote_filename_if_needed
+    (exec_from_conf "ocamlfind") ); x]
 
 (* This lists all supported packages. *)
 let find_packages () =
--- ./src/plugins/ocamlbuild/OCamlbuildCommon.ml
+++ ./src/plugins/ocamlbuild/OCamlbuildCommon.ml
@@ -82,7 +82,7 @@
 
       begin
         match args.plugin_tags with
-        | Some t -> ["-plugin-tag"; Filename.quote t]
+        | Some t -> ["-plugin-tag"; OASISHostPath.quote t]
         | None -> []
       end;
 
--- ./src/plugins/omake/OMakeEquip.ml
+++ ./src/plugins/omake/OMakeEquip.ml
@@ -197,6 +197,15 @@
   subst [] ' ' 0
 
 
+let file_exists_case fln =
+  if Sys.file_exists fln = false then
+    false
+  else
+    let dir = Filename.dirname fln in
+    let base = Filename.basename fln in
+    let files = Array.to_list (Sys.readdir dir) in
+    List.mem base files
+
 let fixup_module_case dir name =
   let name_cap = OASISUnixPath.capitalize_file name in
   let name_uncap = OASISUnixPath.uncapitalize_file name in
@@ -205,7 +214,7 @@
       List.find
         (fun (name,ext) ->
            let file = OASISUnixPath.concat dir (name ^ ext) in
-           Sys.file_exists
+           file_exists_case
              (OASISHostPath.of_unix file)
         )
         [ name_cap, ".ml";
--- ./test/fake-ocamlfind/FakeOCamlfind.ml
+++ ./test/fake-ocamlfind/FakeOCamlfind.ml
@@ -30,4 +30,18 @@
   in
   let args = Sys.argv in
     args.(0) <- real_ocamlfind;
+    if Sys.os_type <> "Win32" then
     Unix.execv real_ocamlfind args
+    else
+      let pid =
+        Unix.create_process
+          args.(0)
+          args
+          Unix.stdin
+          Unix.stdout
+          Unix.stderr
+      in
+      match snd (Unix.waitpid [] pid) with
+      | Unix.WEXITED n -> exit n
+      | Unix.WSIGNALED _ -> exit 2 (* like OCaml's uncaught exceptions *)
+      | Unix.WSTOPPED _ -> exit 1
--- ./test/test-common/TestCommon.ml
+++ ./test/test-common/TestCommon.ml
@@ -222,6 +222,17 @@
       ~ctxt ?chdir ?foutput ?env ?exit_code ~use_stderr:true
       cmd args
 
+let file_exists_strict sfs fln =
+  if sfs#file_exists fln = false then
+    false
+  else if Sys.os_type <> "Win32" then
+    true
+  else
+    let fln_s = sfs#string_of_filename fln in
+    let dir = Filename.dirname fln_s in
+    let base = Filename.basename fln_s in
+    let dirs = Array.to_list (Sys.readdir dir) in
+    List.mem base dirs
 
 let assert_oasis_cli
     ~ctxt
--- ./test/test-common/TestFullUtils.ml
+++ ./test/test-common/TestFullUtils.ml
@@ -35,11 +35,11 @@
 
 
 let exec fn =
-  if Sys.os_type = "Win32" then
-    fn^".exe"
-  else
+  if Sys.os_type <> "Win32" ||
+     Filename.check_suffix (OASISString.lowercase_ascii fn) ".exe" then
     fn
-
+  else
+    fn ^ ".exe"
 
 (* Print a short version of the filename *)
 let fn_printer ~root fn = FilePath.make_relative root fn
@@ -192,9 +192,14 @@
 
 
 (* Create tree structure for a test project and copy it there. *)
-let setup_test_directories test_ctxt ~is_native ~native_dynlink dn =
+let setup_test_directories ?tmpdir_prefix test_ctxt ~is_native ~native_dynlink dn =
   (* Create a temporary directory. *)
-  let tmpdir = bracket_tmpdir test_ctxt in
+  let prefix =
+    match tmpdir_prefix with
+      | None -> "ounit-"
+      | Some x -> x
+  in
+  let tmpdir = bracket_tmpdir ~prefix test_ctxt in
 
   (* Copy sources in this temporary directory. *)
   let src_dir =
@@ -256,7 +261,7 @@
 (* Precompile setup.ml to speedup the tests, if possible. *)
 let rec precompile_setup_ml test_ctxt t =
   let setup_exe =
-    Filename.concat t.precompile_dir (Filename.chop_extension setup_ml)
+    exec (Filename.concat t.precompile_dir (Filename.chop_extension setup_ml))
   in
   let full_setup_ml = in_src_dir t setup_ml in
 
@@ -280,16 +285,17 @@
     let timer = timer_start "precompile_setup_ml" in
     let exit_code =
       FileUtil.cp ~force:FileUtil.Force [full_setup_ml] t.precompile_dir;
-      Sys.command ("ocamlfind ocamlc -o "^setup_exe^" "
-                   ^(Filename.concat t.precompile_dir setup_ml))
+      let f1 = Filename.quote setup_exe in
+      let f2 = Filename.quote (Filename.concat t.precompile_dir setup_ml) in
+        Sys.command ("ocamlfind ocamlc -o "^f1^" "^f2)
     in
     timer_stop test_ctxt timer;
     if exit_code = 0 then begin
       (* Compilation succeed, update the digest *)
-      logf test_ctxt `Info "Compilation of setup.ml succeeds.";
+      logf test_ctxt `Info "Compilation of setup.ml (%S) succeeds." setup_exe;
       `Done_for (Digest.file full_setup_ml)
     end else begin
-      logf test_ctxt `Warning "Compilation of setup.ml doesn't succeed.";
+      logf test_ctxt `Warning "Compilation of setup.ml (%S) doesn't succeed." setup_exe;
       `Not_possible
     end
   in
@@ -308,7 +314,7 @@
 
       | `Done_for digest ->
           if (Digest.file full_setup_ml) = digest then begin
-            Some (exec setup_exe)
+            Some (setup_exe)
           end else begin
             t.setup_ml_precompiled <- compile ();
             precompile_setup_ml test_ctxt t
@@ -538,6 +544,10 @@
   | InstalledBin of filename list
 
 
+
+let system =
+  (BaseOCamlcConfig.var_define "system") ()
+
 (* Register a set of files expected to be built. *)
 let register_installed_files test_ctxt t installed_files_lst =
   let rec file_list =
@@ -605,7 +615,12 @@
                acc
            | "a" ->
                let fn =
-                 if is_win32 then FilePath.replace_extension fn "lib" else fn
+                 if not is_win32 then
+                   fn
+                 else
+                   match system with
+                     | "mingw" | "mingw64" -> fn
+                     | _ -> FilePath.replace_extension fn "lib"
                in
                  if (* library matching the .cmxa *)
                    t.is_native ||
@@ -617,7 +632,7 @@
                    (* no .a matching bytecode only library. *)
                    acc
            | "so" when is_win32 ->
-               (FilePath.replace_extension fn ".dll") :: acc
+               (FilePath.replace_extension fn "dll") :: acc
            | "html" when
                FilePath.basename fn = "index_extensions.html" 
                && OASISVersion.StringVersion.compare t.ocaml_version "4.02" < 0 ->
--- ./test/test-main/TestOASISLibrary.ml
+++ ./test/test-main/TestOASISLibrary.ml
@@ -44,7 +44,7 @@
                   ~ctxt
                   (cs, bs, lib)
                   (fun fn ->
-                     sfs#file_exists (OASISFileSystem.of_unix_filename fn))
+                     file_exists_strict sfs (OASISFileSystem.of_unix_filename fn))
               in
               (List.flatten (List.rev_map snd lst)) @ acc
             | Object _ | Executable _ | Flag _ | SrcRepo _ | Test _ | Doc _ ->
--- ./test/test-main/TestOASISObject.ml
+++ ./test/test-main/TestOASISObject.ml
@@ -44,7 +44,7 @@
                   ~ctxt
                   (cs, bs, obj)
                   (fun fn ->
-                     sfs#file_exists (OASISFileSystem.of_unix_filename fn))
+                     file_exists_strict sfs (OASISFileSystem.of_unix_filename fn))
               in
               (List.flatten (List.rev_map snd lst)) @ acc
             | Library _ | Executable _ | Flag _ | SrcRepo _ | Test _ | Doc _ ->
--- ./test/test-main/TestPluginOCamlbuild.ml
+++ ./test/test-main/TestPluginOCamlbuild.ml
@@ -27,6 +27,26 @@
 open OASISFileTemplate
 open TestFullUtils
 
+let fln_normalize =
+  if Sys.os_type <> "Win32" then
+    fun a -> a
+  else
+    fun str ->
+      let str =
+        let str_lower = OASISString.lowercase_ascii str in
+        if Filename.check_suffix str_lower ".exe" then
+          Filename.chop_extension str ^ ".exe"
+        else
+          str
+      in
+      let len = String.length str in
+      let b = Buffer.create len in
+      for i = 0 to len - 1 do
+        match String.get str i with
+        | '/' -> Buffer.add_char b '\\'
+        | c -> Buffer.add_char b c
+      done;
+      Buffer.contents b
 
 let all_tests =
   [
@@ -52,10 +72,12 @@
        let env = BaseEnvLight.load ~filename:(in_src_dir t "setup.data") () in
        let () =
          assert_equal ~printer:(Printf.sprintf "%S")
-           fake_ocamlfind
-           (BaseEnvLight.var_get "ocamlfind" env);
+           (fln_normalize fake_ocamlfind)
+           (fln_normalize (BaseEnvLight.var_get "ocamlfind" env));
          run_ocaml_setup_ml ~extra_env test_ctxt t ["-build"]
        in
+       (* ocamlbuild is called with -no-log on win32 *)
+       skip_if (Sys.os_type = "Win32") "UNIX test";
        let build_log =
          file_content (in_src_dir t (Filename.concat "_build" "_log"))
        in
@@ -63,11 +85,15 @@
          List.iter
            (fun line ->
               if OASISString.contains ~what:"ocamlfind" line then
+                let what =
+                  Ocamlbuild_pack.Shell.quote_filename_if_needed
+                    fake_ocamlfind
+                in
                 assert_bool
                   (Printf.sprintf
                      "line %S should starts with %S"
                      line fake_ocamlfind)
-                  (OASISString.starts_with ~what:fake_ocamlfind line))
+                  (OASISString.starts_with ~what line))
            (OASISString.nsplit build_log '\n'));
 
     "use-ocamlfind",
